import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Document contents","description":"","frontmatter":{},"headers":[],"relativePath":"server/rest-api/corpus/docs/pid/contents/get.md","filePath":"server/030_rest-api/_corpus/docs/pid/contents/get.md","lastUpdated":1749639304000}');
const _sfc_main = { name: "server/rest-api/corpus/docs/pid/contents/get.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="document-contents" tabindex="-1">Document contents <a class="header-anchor" href="#document-contents" aria-label="Permalink to &quot;Document contents&quot;">​</a></h1> <p>Retrieve the original input document, presuming it&#39;s stored in the corpus (it is by default).</p> <p><strong>URL</strong> : <code>/blacklab-server/&lt;corpus-name&gt;/docs/&lt;pid&gt;/contents</code></p> <p><strong>Method</strong> : <code>GET</code></p> <h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h4> <p>All parameters are optional.  <code>wordstart</code> and <code>wordend</code> refer to token position in a document, 0-based.</p> <p>Partial contents XML output will be wrapped in <code>&lt;blacklabResponse/&gt;</code> element to ensure a single root element.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>patt</code></td> <td>Pattern to highlight in the document. <code>&lt;hl&gt;...&lt;/hl&gt;</code> tags will be added to highlight hits.</td></tr> <tr><td><code>field</code></td> <td>Annotated field to get snippet for.  (default: main annotated field)<br>(<strong>NOTE:</strong> in case of a parallel corpus, you can shorten this to only the version, e.g. <code>nl</code> if you want to get the contents for field <code>contents__nl</code>)</td></tr> <tr><td><code>searchfield</code></td> <td>(parallel corpora only) Annotated field that was searched. Used in conjunction with the <code>rfield()</code> function (see <a href="/guide/query-language/relations.html">relations querying</a>) to highlight the correct hits.<br>(<strong>NOTE:</strong> you can shorten this to only the version, e.g. <code>nl</code> if you searched field <code>contents__nl</code>)</td></tr> <tr><td><code>wordstart</code></td> <td>First word position we want returned. -1 for document start.<br><strong>NOTE:</strong> when greater than -1, any content before the first word will <em>not</em> be included in the response!</td></tr> <tr><td><code>wordend</code></td> <td>First word position we don&#39;t want returned. -1 for document end.<br><strong>NOTE:</strong> when greater than -1, any content after the last word will <em>not</em> be included in the response!</td></tr> <tr><td><code>adjusthits</code></td> <td>(relations queries only) should query hits be adjusted so all matched relations are inside the hit? Default: <code>no</code></td></tr></tbody></table> <h2 id="success-response" tabindex="-1">Success Response <a class="header-anchor" href="#success-response" aria-label="Permalink to &quot;Success Response&quot;">​</a></h2> <p><strong>Code</strong> : <code>200 OK</code></p> <h3 id="content-examples" tabindex="-1">Content examples <a class="header-anchor" href="#content-examples" aria-label="Permalink to &quot;Content examples&quot;">​</a></h3> <p><em>(the original input document, be it XML or some other format)</em></p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("server/030_rest-api/_corpus/docs/pid/contents/get.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const get = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  get as default
};
