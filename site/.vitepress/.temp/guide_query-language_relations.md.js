import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Relations querying","description":"","frontmatter":{},"headers":[],"relativePath":"guide/query-language/relations.md","filePath":"guide/040_query-language/020_relations.md","lastUpdated":1749639304000}');
const _sfc_main = { name: "guide/query-language/relations.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="relations-querying" tabindex="-1">Relations querying <a class="header-anchor" href="#relations-querying" aria-label="Permalink to &quot;Relations querying&quot;">​</a></h1> <div class="tip custom-block"><p class="custom-block-title">Supported from v4.0</p> <p>Indexing and searching relations will be supported from BlackLab 4.0 (and current development snapshots).</p></div> <p>Relations show how (groups of) words are related to one another. One of the most common types of relations is the dependency relation, which shows grammatical dependency between words.</p> <p>If your corpus contains relations, you can query those as well. One advantage of this style of querying is that it&#39;s much easier to find nonadjacent words related to one another, or two related words regardless of what order they occur in.</p> <p>See <a href="/guide/index-your-data/relations.html">Indexing relations</a>.</p> <p>Querying relations is essentially done by building a partial tree of relations constraints. BlackLab will try and find this structure in the corpus. Relations queries can be combined with &quot;regular&quot; token-level queries as well.</p> <div class="tip custom-block"><p class="custom-block-title">Treebank systems</p> <p>BlackLab supports limited relations querying, but is not as powerful as a full
treebank system, which is primarily designed for this style of search. Links to some treebank systems can be found <a href="https://github.com/instituutnederlandsetaal/BlackLab/blob/dev/doc/technical/design/design-relations-queries.md#research-into-treebank-systems" target="_blank" rel="noreferrer">here</a>. For BlackLab&#39;s relations querying limitations, see <a href="#limitation-descendant-search">below</a>.</p></div> <h2 id="an-example-dependency-tree" tabindex="-1">An example dependency tree <a class="header-anchor" href="#an-example-dependency-tree" aria-label="Permalink to &quot;An example dependency tree&quot;">​</a></h2> <p>Let&#39;s use an example to illustrate the various querying options. Here&#39;s a simple dependency tree for the phrase <em>I have a fluffy cat</em>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>      |</span></span>
<span class="line"><span>     have</span></span>
<span class="line"><span>    /    \\</span></span>
<span class="line"><span> (subj)   (obj)</span></span>
<span class="line"><span> /          \\</span></span>
<span class="line"><span>I            cat</span></span>
<span class="line"><span>           /   |</span></span>
<span class="line"><span>        (det)(amod)</span></span>
<span class="line"><span>        /      |</span></span>
<span class="line"><span>       a     fluffy</span></span></code></pre></div><h2 id="finding-specific-relation-types" tabindex="-1">Finding specific relation types <a class="header-anchor" href="#finding-specific-relation-types" aria-label="Permalink to &quot;Finding specific relation types&quot;">​</a></h2> <p>We might want to find object relations in our data. We can do this as follows:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -obj-&gt; _</span></span></code></pre></div><p>This will find <em>have a fluffy cat</em> (the span of text covering the two ends of the relation), with a match info group named for the relation type (<em>obj</em>) containing the relation details between <em>have</em> and <em>cat</em>.</p> <p>The two <code>_</code> marks in the query simply means we only care about the relation type, not the source or target of the relation. If we specifically want to find instances where <em>cat</em> is the object of the sentence, we can use this instead:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -obj-&gt; &quot;cat&quot;</span></span></code></pre></div><p>So you can see that the token-based queries described previously are still useful here.</p> <details class="details custom-block"><summary>Can I use [] instead of _ ?</summary> <p>As explained above, <code>_</code> in a relation expression means &quot;any source or target&quot;. You might be tempted to use <code>[]</code> instead, especially if you know your relations always have a single-token source and target. This works just fine, but it&#39;s a bit slower (it has to double-check that source and target are actually of length 1), so we recommend sticking with <code>_</code>.</p> <p>(the actual equivalent of <code>_</code> here is <code>[]*</code> (zero or more tokens with no restrictions), but that makes for less readable queries)</p></details> <h2 id="a-note-on-terminology" tabindex="-1">A note on terminology <a class="header-anchor" href="#a-note-on-terminology" aria-label="Permalink to &quot;A note on terminology&quot;">​</a></h2> <p>For dependency relations, linguists call the left side the <em>head</em> of the relation and the right side the <em>dependent</em>. However, because dependency relations aren&#39;t the only class of relation, and because the term <em>head</em> can be a bit confusing (there&#39;s also the &quot;head of an arrow&quot;, but that&#39;s the other end!), we will use <em>source</em> and <em>target</em>.</p> <p>When talking about tree structures, we will also use <em>parent</em> and <em>child</em>.</p> <table tabindex="0"><thead><tr><th>Context</th> <th>Terms</th></tr></thead> <tbody><tr><td>Dependency relations</td> <td><code>head --&gt; dependent</code></td></tr> <tr><td>Relations in BlackLab</td> <td><code>source --&gt; target</code></td></tr> <tr><td>Searching tree structures</td> <td><code>parent --&gt; child</code></td></tr></tbody></table> <h2 id="finding-relation-types-using-regular-expressions" tabindex="-1">Finding relation types using regular expressions <a class="header-anchor" href="#finding-relation-types-using-regular-expressions" aria-label="Permalink to &quot;Finding relation types using regular expressions&quot;">​</a></h2> <p>We can specify the relation type as a regular expression as well. To find both subject and object relations, we could use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -subj|obj-&gt; _</span></span></code></pre></div><p>or:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -.*bj-&gt; _</span></span></code></pre></div><p>If you find it clearer, you can use parentheses around the regular expression:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -(subj|obj)-&gt; _</span></span></code></pre></div><p>With our example tree, the above queries will find all subject relations and all object relations. Each hit will have one relation in the match info. To find multiple relations per hit, read on.</p> <details class="details custom-block"><summary>Relation classes</summary> <p>When indexing relations in BlackLab, you assign them a <em>class</em>, a short string indicating what family of relations it belongs to. For example, you could assign the class string <code>dep</code> to dependency relations. An <code>obj</code> relation would become <code>dep::obj</code>.</p> <p>To simplify things, <code>rel</code> is the default relation class in BlackLab. If you index relations without a class, they will automatically get this class. Similarly, when searching, if you don&#39;t specify a class, <code>rel::</code> will be prepended to the relation type. So if you&#39;re not indexing different classes of relations, you can just ignore the classes.</p></details> <h2 id="root-relations" tabindex="-1">Root relations <a class="header-anchor" href="#root-relations" aria-label="Permalink to &quot;Root relations&quot;">​</a></h2> <p>A dependency tree has a single root relation. A root relation is special relation that only has a target and no source. Its relation type is usually just called <em>root</em>. In our example, the root points to the word <em>have</em>.</p> <p>You can find root relations with a special unary operator:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^--&gt; _</span></span></code></pre></div><p>This will find all root relations. The details for the root relation will be returned in the match info.</p> <p>Of course you can place constraints on the target of the root relation as well:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^--&gt; &quot;have&quot;</span></span></code></pre></div><p>This will only find root relations pointing to the word <em>have</em>.</p> <h2 id="finding-two-relations-with-the-same-source" tabindex="-1">Finding two relations with the same source <a class="header-anchor" href="#finding-two-relations-with-the-same-source" aria-label="Permalink to &quot;Finding two relations with the same source&quot;">​</a></h2> <p>What if we want to find the subject and object relations of a sentence, both linked to the same source (the verb in the sentence)? We can do that using a semicolon to separate the two <em>target constraints</em> (or <em>child constraints</em>):</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -subj-&gt; _ ;</span></span>
<span class="line"><span>  -obj-&gt; _</span></span></code></pre></div><p>As you can see, the source or parent is specified only once at the beginning. Then you may specify one or more target constraints (a relation type plus target, e.g. <code>-subj-&gt; _</code>), separated by semicolons.</p> <p>The above query will find hits covering the words involved in both relations, with details for the two relations in the match info of each hit. In our example, it would find the entire sentence <em>I have a fluffy cat</em>.</p> <details class="details custom-block"><summary>Target constraint uniqueness</summary> <p>Note that when matching multiple relations with the same source this way, BlackLab will enforce that they are unique. That is, two target constraints will only match two different relations.</p></details> <h2 id="negative-child-constraints" tabindex="-1">Negative child constraints <a class="header-anchor" href="#negative-child-constraints" aria-label="Permalink to &quot;Negative child constraints&quot;">​</a></h2> <p>You may want to have negative constraints, such as making sure that <em>dog</em> is not the object of the sentence. This can be done by prefixing the relation operator with <code>!</code>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_  -subj-&gt; _ ;</span></span>
<span class="line"><span>  !-obj-&gt; &quot;dog&quot;</span></span></code></pre></div><p>Note that this is different from :</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_  -subj-&gt; _ ;</span></span>
<span class="line"><span>   -obj-&gt; [word != &quot;dog&quot;]</span></span></code></pre></div><p>The second query requires an object relation where the target is a word other than <em>dog</em>; that is, the object relation must exist. By contrast, in the first case, we only require that there exists no object relation with the target <em>dog</em>, so this might match sentences without an object as well as sentences with an object that is not <em>dog</em>.</p> <h2 id="searching-over-multiple-levels-in-the-tree" tabindex="-1">Searching over multiple levels in the tree <a class="header-anchor" href="#searching-over-multiple-levels-in-the-tree" aria-label="Permalink to &quot;Searching over multiple levels in the tree&quot;">​</a></h2> <p>What if we want to query over multiple levels of the tree? For example, we want to find sentences where the target of the <code>subj</code> relation is the source of an <code>amod</code> relation pointing to <em>fluffy</em>, such as in our example tree.</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -subj-&gt; _ -amod-&gt; &quot;fluffy&quot;</span></span></code></pre></div><p>We can combine the techniques as well, for example if we also want to find the object of the sentence like before:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>_ -subj-&gt; (_ -amod-&gt; _) ;</span></span>
<span class="line"><span>  -obj-&gt; _</span></span></code></pre></div><p>As you can see, the value of the expression <code>(_ -amod-&gt; _)</code> is actually the <em>source</em> of the <code>amod</code> relation, so we can easily use it as the target of the <code>subj</code> relation.</p> <p>The <code>-..-&gt;</code> operator is right-associative (as you can see from the first example), but we do need parentheses here, or the parent of the <code>-obj-&gt;</code> relation would be ambiguous.</p> <h2 id="limitation-descendant-search" tabindex="-1">Limitation: descendant search <a class="header-anchor" href="#limitation-descendant-search" aria-label="Permalink to &quot;Limitation: descendant search&quot;">​</a></h2> <p>One current limitation compared to dedicated treebank systems is the lack
of support for finding descendants that are not direct children.</p> <p>For example, if we want to look for sentences with the verb <em>have</em> and the word <em>fluffy</em> somewhere as an adjectival modifier in that sentence, we can&#39;t query something like this:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^--&gt; &quot;have&quot; --&gt;&gt; -amod-&gt; &quot;fluffy&quot;   # DOES NOT WORK</span></span></code></pre></div><p>Instead, we have to know how many nodes are between <em>have</em> and <em>fluffy</em>, e.g. this does work:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^--&gt; &quot;have&quot; --&gt; _ -amod-&gt; &quot;fluffy&quot;</span></span></code></pre></div><p>Supporting arbitrary descendant search with decent performance is a challenge that we may try to tackle in the future.</p> <p>For now, you might be able to work around this limitation using a hybrid between token-based and relations querying, e.g.:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(&lt;s/&gt; containing (^--&gt; &quot;have&quot;)) containing (_ -amod-&gt; &quot;fluffy&quot;)</span></span></code></pre></div><h2 id="advanced-relations-querying-features" tabindex="-1">Advanced relations querying features <a class="header-anchor" href="#advanced-relations-querying-features" aria-label="Permalink to &quot;Advanced relations querying features&quot;">​</a></h2> <p>Most users won&#39;t need this, but they might come in handy in some cases.</p> <h3 id="controlling-the-resulting-span" tabindex="-1">Controlling the resulting span <a class="header-anchor" href="#controlling-the-resulting-span" aria-label="Permalink to &quot;Controlling the resulting span&quot;">​</a></h3> <p>As shown in the previous section, relation expressions return the source of the matching relation by default. But what if you want a different part of the relation?</p> <p>For example, if we want to find targets of the <em>amod</em> relation, we can do this:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rspan(_ -amod-&gt; _, &quot;target&quot;)</span></span></code></pre></div><p>If we want the entire span covering both the source and the target (and anything in between):</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rspan(_ -amod-&gt; _, &quot;full&quot;)</span></span></code></pre></div><p>Note that <em>full</em> is the default value for the second parameter, so this will work too:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rspan(_ -amod-&gt; _)</span></span></code></pre></div><p><code>rspan</code> supports another option: <em>all</em> will return a span covering all of the relations matched by your query.</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rspan(_ -subj-&gt; (_ -amod-&gt; _) ; -obj-&gt; _, &quot;all&quot;)</span></span></code></pre></div><p>Because this is pretty useful when searching relations, there&#39;s an easy way to apply this <code>rspan</code> operation: just add a parameter <code>adjusthits=true</code> to your BlackLab Server URL. Note that if your query already starts with a call to <code>rspan</code>, <code>adjusthits=true</code> won&#39;t do anything.</p> <h3 id="capturing-all-relations-in-a-sentence" tabindex="-1">Capturing all relations in a sentence <a class="header-anchor" href="#capturing-all-relations-in-a-sentence" aria-label="Permalink to &quot;Capturing all relations in a sentence&quot;">​</a></h3> <p>If you want to capture all relations in the sentence containing your match, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;elephant&quot; within rcapture(&lt;s/&gt;)</span></span></code></pre></div><p>What actually happens here is that all relations in the matched clause are returned in the match info.</p> <p>You can pass a second parameter with the match info name for the list of captured relations (defaults to <em>captured_rels</em>):</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;elephant&quot; within rcapture(&lt;s/&gt;, &quot;relations&quot;)</span></span></code></pre></div><p>If you only want to capture certain relations, you specify a third parameter that is a regular expression filter on the relation type. For example, to only capture relations in the <code>fam</code> class, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;elephant&quot; within rcapture(&lt;s/&gt;, &quot;relations&quot;, &quot;fam::.*&quot;)</span></span></code></pre></div><h3 id="cross-field-relations" tabindex="-1">Cross-field relations <a class="header-anchor" href="#cross-field-relations" aria-label="Permalink to &quot;Cross-field relations&quot;">​</a></h3> <p>It is possible to have a corpus with multiple annotated fields, with relations that point from a position or span in one field to another. Annotated fields should be named e.g. <code>contents__original</code> and <code>contents__corrected</code> for this to work, and a relation from the first to the second field could be found like this:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;mistpyed&quot; --&gt;corrected &quot;mistyped&quot;</span></span></code></pre></div><p>As you can see, the target version is appended to the relation operator. The source version is determined by the main annotated field searched (the <code>field</code> parameter for BlackLab Server; will default to the main annotated field, which is the first one you defined in your indexing configuration).</p> <p>Cross-field relations are used to enable parallel corpora, which we&#39;ll discuss <a href="./parallel.html">next</a>.</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("guide/040_query-language/020_relations.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _020_relations = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _020_relations as default
};
