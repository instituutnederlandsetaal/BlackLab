import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Processing values","description":"","frontmatter":{},"headers":[],"relativePath":"guide/index-your-data/processing-values.md","filePath":"guide/030_index-your-data/050_processing-values.md","lastUpdated":1749640928000}');
const _sfc_main = { name: "guide/index-your-data/processing-values.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="processing-values" tabindex="-1">Processing values <a class="header-anchor" href="#processing-values" aria-label="Permalink to &quot;Processing values&quot;">â€‹</a></h1> <p>It is often useful to do some simple processing on a value just before it&#39;s added to the index. This could be a simple search and replace, or combining two fields into one for easier searching, etc. Or you might want to map a whole collection of values to different values. Both are possible.</p> <div class="tip custom-block"><p class="custom-block-title">Processing steps, or everything in XPath?</p> <p>When using <code>processor: saxon</code>, you can often achieve the same results using XPath expressions (<a href="./xpath-examples.html">examples</a>).</p> <p>Just use what works best in your case. Of course, when indexing a non-XML format such as CSV, processing steps are the
only option.</p></div> <p>To perform simple value mapping on a metadata field, use the <code>map</code> action in the <code>process</code> section:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">metadata</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">  containerPath</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">metadata</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">  fields</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">  - </span><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">name</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">speciesGroup</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">    valuePath</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">species</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">    process</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">    # Map (translate) values (key will be translated to corresponding value)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">    # In this example: translate species to the group they belong to</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    - </span><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">action</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">map</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">      table</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">        dog</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">mammals</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">        cat</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">mammals</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">        shark</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">fish</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">        herring</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">fish</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">        # etc.</span></span></code></pre></div><p><code>process</code> can be used to perform simple string processing on (standoff) (sub)annotations and metadata values.</p> <p>For example, to process a metadata field value, simply add the <code>process</code> key with a list of actions to perform, like so:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">metadata</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">  containerPath</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">metadata</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">  fields</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">  - </span><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">name</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">author</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">    valuePath</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">author</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    </span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">    # Do some processing on the contents of the author element before indexing</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">    process</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">:</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    </span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">      # If empty, set a default value</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    - </span><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">action</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">ifempty</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">      value</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&quot;(unknown)&quot;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">                          </span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#6A737D", "--shiki-dark": "#6A737D" })}">      # Normalize spaces</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    - </span><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">action</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">replace</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">      find</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&quot;</span><span style="${ssrRenderStyle({ "--shiki-light": "#005CC5", "--shiki-dark": "#79B8FF" })}">\\\\</span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">s</span><span style="${ssrRenderStyle({ "--shiki-light": "#005CC5", "--shiki-dark": "#79B8FF" })}">\\\\</span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">s+&quot;</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#22863A", "--shiki-dark": "#85E89D" })}">      replace</span><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">: </span><span style="${ssrRenderStyle({ "--shiki-light": "#032F62", "--shiki-dark": "#9ECBFF" })}">&quot; &quot;</span></span></code></pre></div><p>These are all the available generic processing steps:</p> <table tabindex="0"><thead><tr><th>Processing Step</th> <th>Parameters</th> <th>Description</th></tr></thead> <tbody><tr><td><code>replace</code></td> <td><code>find</code><br><code>replace</code><br>[<code>keep</code>]</td> <td>Do a regex search for <code>find</code> and replace each match with <code>replace</code>. Group references may be used. An optional parameter <code>keep</code> can be set to <code>both</code> to keep both the original strings and the results after applying the replace operation.</td></tr> <tr><td><code>ifempty</code></td> <td><code>value</code> or <code>field</code></td> <td>If current value is the empty string, set its value to either the specified <code>value</code> or the value of the specified <code>field</code>. If you refer to a <code>field</code>, make sure it is defined before this field (fields are processed in order). (NOTE: this processing step was previously called <code>default</code>)</td></tr> <tr><td><code>append</code></td> <td><code>value</code> or <code>field</code><br>[<code>separator</code>]</td> <td>Append the specified <code>value</code> or the value of the specified <code>field</code>, using a space as the separator character. You may also specify a different <code>separator</code> if you wish, including the empty string (<code>&quot;&quot;</code>).</td></tr> <tr><td><code>split</code></td> <td>[<code>separator</code>]<br>[<code>keep</code>]</td> <td>Split the field&#39;s value on the given separator and keep only the part indicated by <code>keep</code> (0-based). If <code>keep</code> is omitted, keep the first part. If <code>separator</code> is omitted, use <code>;</code>. The separator is a regex, and to split on special characters, those should be escaped by using a double backslash (<code>\\\\</code>). <code>keep</code> also allows two special values: <code>all</code> to keep all splits (instead of only the one at an index), and <code>both</code> to keep both the unsplit value as well as all the split parts.</td></tr> <tr><td><code>strip</code></td> <td>[<code>chars</code>]</td> <td>Strip specified chars from beginning and end. If <code>chars</code> is omitted, use space.</td></tr> <tr><td><code>map</code></td> <td><code>table</code></td> <td>Map values to other values. The table is a map from input to output values. If the input value is not in the table, it is left unchanged.</td></tr> <tr><td><code>sort</code></td> <td></td> <td>Sort multiple values using the default collator. This may help to ensure that the first term (which is the one used for sorting and grouping) is more predictable.</td></tr> <tr><td><code>unique</code></td> <td></td> <td>Remove duplicate values from the field. You normally never need to do this as it is done automatically just before actually indexing the final terms.</td></tr></tbody></table> <p>These processing steps are more specific to certain data formats:</p> <table tabindex="0"><thead><tr><th>Processing Step</th> <th>Parameters</th> <th>Description</th></tr></thead> <tbody><tr><td><code>parsePos</code></td> <td><code>fieldName</code></td> <td>Parse common part of speech expressions of the form <code>A(b=c,d=e)</code> where A is the main part of speech (e.g. <code>N</code> for noun), and b=c is a part of speech feature such as number=plural, etc. If you don&#39;t specify field (or specify an underscore <code>_</code> for field), the main part of speech is extracted. If you specify a feature name (e.g. <code>number</code>), that feature is extracted.</td></tr> <tr><td><code>chatFormatAgeToMonths</code></td> <td></td> <td>Convert age as reported in CHAT format to number of months.</td></tr> <tr><td><code>concatDate</code></td> <td><code>yearField</code><br><code>monthField</code><br><code>dayField</code><br><code>autofill</code></td> <td>Concatenate 3 separate date fields into one, substituting unknown months and days with the first or last possible value. The output format is YYYYMMDD. Numbers are padded with leading zeroes.<br>Requires 4 arguments:**<br><code>yearField</code>: the metadata field containing the numeric year<br><code>monthField</code>: the metadata field containing the numeric month (so &quot;12&quot; instead of &quot;december&quot; or &quot;dec&quot;)<br><code>dayField</code>: the metadata field containing the numeric day<br><code>autofill</code>: <code>start</code> to autofill missing month and day to the first possible value (01), or <code>end</code> to autofill the last possible value (12 for months, last day of the month in that year for days - takes into account leap years).<br>This step requires that at least the year is known. If the year is not known, no output is generated.</td></tr> <tr><td>If you would like a new processing step to be added, please let us know.</td> <td></td> <td></td></tr></tbody></table></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("guide/030_index-your-data/050_processing-values.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _050_processingValues = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  _050_processingValues as default
};
