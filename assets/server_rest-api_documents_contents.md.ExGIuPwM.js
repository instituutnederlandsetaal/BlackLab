import{_ as t,c as o,o as n,al as r}from"./chunks/framework.B3j7FRen.js";const u=JSON.parse('{"title":"Document contents","description":"","frontmatter":{},"headers":[],"relativePath":"server/rest-api/documents/contents.md","filePath":"server/030_rest-api/020_documents/020_contents.md","lastUpdated":1752044654000}'),a={name:"server/rest-api/documents/contents.md"};function d(s,e,c,i,l,h){return n(),o("div",null,e[0]||(e[0]=[r('<h1 id="document-contents" tabindex="-1">Document contents <a class="header-anchor" href="#document-contents" aria-label="Permalink to &quot;Document contents&quot;">​</a></h1> <p>Retrieve the original input document, presuming it&#39;s stored in the corpus (it is by default).</p> <p><strong>URL</strong> : <code>/blacklab-server/&lt;corpus-name&gt;/docs/&lt;pid&gt;/contents</code></p> <p><strong>Method</strong> : <code>GET</code></p> <h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h4> <p>All parameters are optional.  <code>wordstart</code> and <code>wordend</code> refer to token position in a document, 0-based.</p> <p>Partial contents XML output will be wrapped in <code>&lt;blacklabResponse/&gt;</code> element to ensure a single root element.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>patt</code></td> <td>Pattern to highlight in the document. <code>&lt;hl&gt;...&lt;/hl&gt;</code> tags will be added to highlight hits.</td></tr> <tr><td><code>field</code></td> <td>Annotated field to get snippet for.  (default: main annotated field)<br>(<strong>NOTE:</strong> in case of a parallel corpus, you can shorten this to only the version, e.g. <code>nl</code> if you want to get the contents for field <code>contents__nl</code>)</td></tr> <tr><td><code>searchfield</code></td> <td>(parallel corpora only) Annotated field that was searched. Used in conjunction with the <code>rfield()</code> function (see <a href="/guide/query-language/relations.html">relations querying</a>) to highlight the correct hits.<br>(<strong>NOTE:</strong> you can shorten this to only the version, e.g. <code>nl</code> if you searched field <code>contents__nl</code>)</td></tr> <tr><td><code>wordstart</code></td> <td>First word position we want returned. -1 for document start.<br><strong>NOTE:</strong> when greater than -1, any content before the first word will <em>not</em> be included in the response!</td></tr> <tr><td><code>wordend</code></td> <td>First word position we don&#39;t want returned. -1 for document end.<br><strong>NOTE:</strong> when greater than -1, any content after the last word will <em>not</em> be included in the response!</td></tr> <tr><td><code>adjusthits</code></td> <td>(relations queries only) should query hits be adjusted so all matched relations are inside the hit? Default: <code>no</code></td></tr></tbody></table> <h2 id="success-response" tabindex="-1">Success Response <a class="header-anchor" href="#success-response" aria-label="Permalink to &quot;Success Response&quot;">​</a></h2> <p><strong>HTTP response code</strong>: <code>200 OK</code></p> <h3 id="content-examples" tabindex="-1">Content examples <a class="header-anchor" href="#content-examples" aria-label="Permalink to &quot;Content examples&quot;">​</a></h3> <p><em>(the original input document, be it XML or some other format)</em></p>',23)]))}const m=t(a,[["render",d]]);export{u as __pageData,m as default};
