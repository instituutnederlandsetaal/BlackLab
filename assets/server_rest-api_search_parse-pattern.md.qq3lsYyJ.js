import{_ as t,c as e,o as i,al as a}from"./chunks/framework.B3j7FRen.js";const k=JSON.parse('{"title":"Parse a pattern","description":"","frontmatter":{},"headers":[],"relativePath":"server/rest-api/search/parse-pattern.md","filePath":"server/030_rest-api/010_search/050_parse-pattern.md","lastUpdated":1752044654000}'),d={name:"server/rest-api/search/parse-pattern.md"};function n(o,s,l,r,p,h){return i(),e("div",null,s[0]||(s[0]=[a(`<h1 id="parse-a-pattern" tabindex="-1">Parse a pattern <a class="header-anchor" href="#parse-a-pattern" aria-label="Permalink to &quot;Parse a pattern&quot;">​</a></h1> <p>Parse a text pattern, returning the JSON query structure without actually executing the search.</p> <p>This operation can be useful when e.g. building a query parser, especially if you want to be able to switch back and forth between the query parser and an input field where the user can manually enter BlackLab Corpus Query Language.</p> <p>If you don&#39;t specify <code>pattlang</code>, the pattern type passed in <code>patt</code> will be autodetected (CorpusQL or JSON query structure). But if you know you&#39;re passing in JSON, it&#39;s best to set <code>pattlang</code> to <code>json</code>. This will give a relevant error message if parsing fails.</p> <p><strong>NOTE:</strong> this operation only supports the JSON response type. Requesting XML will result in an error.</p> <p><strong>URL</strong> : <code>/blacklab-server/&lt;corpus-name&gt;/parse-pattern</code></p> <p><strong>Method</strong> : <code>GET</code></p> <h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h4> <p>The <code>patt</code> parameter is required.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>patt</code></td> <td><a href="/guide/query-language/">BlackLab Corpus Query Language</a> (BCQL) pattern to search for</td></tr> <tr><td><code>pattlang</code></td> <td>pattern language to use for <code>patt</code>. Defaults to <code>bcql</code> (BlackLab Corpus Query Language). The other values (<code>contextql</code> and <code>luceneql</code>) have very limited support at the moment.  Other, more useful query languages may be added in the future.</td></tr></tbody></table> <p><strong>NOTE:</strong> <code>pattgapdata</code> is not supported for this endpoint! (this is a rarely-used feature that might be removed in the future)</p> <h2 id="success-response" tabindex="-1">Success Response <a class="header-anchor" href="#success-response" aria-label="Permalink to &quot;Success Response&quot;">​</a></h2> <p><strong>HTTP response code</strong>: <code>200 OK</code></p> <p>Note: if parsing the pattern fails, the request will still succeed, but the response will contain an error message (in <code>parsed.error</code>).</p> <h3 id="content-examples" tabindex="-1">Content examples <a class="header-anchor" href="#content-examples" aria-label="Permalink to &quot;Content examples&quot;">​</a></h3> <p>In the result object, <code>params</code> contains the parameters passed in, and <code>parsed</code> contains the parsed pattern, both in JSON query structure form and as re-serialized CorpusQL.</p> <p>The re-serialized CorpusQL may have slight differences from your input CorpusQL, e.g. extra or fewer parentheses, but they should be semantically identical.</p> <p>Result for <code>/parse-pattern?patt=%27de%27</code>:</p> <div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;params&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;patt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[word=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">de</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;pattlang&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;default&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;parsed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;bcql&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[word=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">de</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;regex&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            &quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;de&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            &quot;annotation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;word&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Result for <code>/parse-pattern?outputformat=json&amp;patt=%7B&quot;type&quot;%3A&quot;posfilter&quot;%2C&quot;producer&quot;%3A%7B&quot;type&quot;%3A%20&quot;regex&quot;%2C&quot;value&quot;%3A%20&quot;de&quot;%7D%2C&quot;filter&quot;%3A%20%7B&quot;type&quot;%3A%20&quot;tags&quot;%2C&quot;name&quot;%3A%20&quot;s&quot;%7D%2C&quot;operation&quot;%3A%20&quot;within&quot;%7D</code>:</p> <div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;params&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;patt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">type</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">posfilter</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">producer</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">:{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">type</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">regex</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">value</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">de</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">filter</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">type</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">tags</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">name</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">operation</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">within</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;pattlang&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;default&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;parsed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;bcql&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&#39;de&#39; within &lt;s/&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;posfilter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;producer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;regex&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;de&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;filter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tags&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;s&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;operation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;within&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="notes" tabindex="-1">Notes <a class="header-anchor" href="#notes" aria-label="Permalink to &quot;Notes&quot;">​</a></h2> <ul><li>it is in theory possible to create a JSON query structure that cannot be (re-)serialized to BlackLab Corpus Query Language, although structures from parsing CorpusQL can always be reserialized of course. Should serialization fail, the <code>corpusql</code> key will be missing from the response and the <code>corpusql-error</code> key will indicate why the pattern couldn&#39;t be serialized.</li></ul> <h2 id="json-query-structure" tabindex="-1">JSON query structure <a class="header-anchor" href="#json-query-structure" aria-label="Permalink to &quot;JSON query structure&quot;">​</a></h2> <table tabindex="0"><thead><tr><th><code>type</code></th> <th>properties</th> <th>CorpusQL equivalent</th> <th>Notes</th></tr></thead> <tbody><tr><td><code>and</code></td> <td><code>clauses</code></td> <td><code>clauses[0] &amp; ...</code></td> <td></td></tr> <tr><td><code>anytoken</code></td> <td><code>min</code>[,<code>max</code>]</td> <td><code>[]{min,max}</code><br><code>[]{min,</code>}<br><code>[]{*|+|?}</code></td> <td><code>max</code> omitted if there is no limit</td></tr> <tr><td><code>capture</code></td> <td><code>clause</code>,<code>capture</code></td> <td><code>capture:(clause)</code></td> <td><code>clause</code> will be captured using name <code>capture</code></td></tr> <tr><td><code>constrained</code></td> <td><code>clause</code>,<code>constraint</code></td> <td><code>clause :: constraint</code></td> <td>e.g. <code>A:[] &quot;and&quot; B:[] :: A.word = B.word</code></td></tr> <tr><td><code>defval</code></td> <td></td> <td><code>_</code></td> <td>used in relations queries (&quot;don&#39;t care&quot; value) and function calls (&quot;use default value&quot;)</td></tr> <tr><td><code>not</code></td> <td><code>clause</code></td> <td><code>!clause</code></td> <td></td></tr> <tr><td><code>or</code></td> <td><code>clauses</code></td> <td><code>clauses[0] | ...</code></td> <td></td></tr> <tr><td><code>posfilter</code></td> <td><code>producer</code>,<code>filter</code>,<code>operation</code>[, ...]</td> <td><code>producer within filter</code><br><code>producer containing filter</code></td> <td>When parsing CorpusQL, you will only get <code>producer,</code>filter<code>and</code>operation<code>(which will be</code>within<code>or</code>containing\`). Other parameters are used internally.</td></tr> <tr><td><code>callfunc</code></td> <td><code>name</code>,<code>args</code></td> <td><code>name(...args)</code></td> <td>E.g. <code>rel(&#39;det&#39;, [])</code></td></tr> <tr><td><code>regex</code></td> <td><code>value</code>[,<code>annotation</code>,<code>sensitivity</code>]</td> <td><code>[annotation=&quot;value&quot;]</code><br><code>&quot;value&quot;</code></td> <td><code>sensitivity</code> is used internally.</td></tr> <tr><td><code>relmatch</code></td> <td><code>parent</code>,<code>children</code></td> <td><code>parent --&gt;children[0] ; ...</code></td> <td>See <code>reltarget</code> for the child clauses.</td></tr> <tr><td><code>reltarget</code></td> <td><code>reltype</code>,<code>clause</code>[,<code>negate</code>,<code>spanmode</code>,<code>direction</code>,<code>capture</code>]</td> <td><code>-reltype-&gt; clause</code><br><code>!-reltype-&gt; clause</code><br><code>^-reltype-&gt; clause</code><br><code>capture:-reltype-&gt; clause</code></td> <td><code>negate</code> defaults to <code>false</code>, <code>spanmode</code> to <code>source</code>, <code>direction</code> to <code>both</code>, <code>capture</code> to empty string. Set <code>direction</code> to <code>root</code> and <code>spanmode</code> to <code>target</code> for root relations (relations without a source).</td></tr> <tr><td><code>repeat</code></td> <td><code>clause</code>,<code>min</code>[,<code>max</code>]</td> <td><code>clause{min,max}</code><br><code>clause{min,</code>}<br><code>clause{*|+|?}</code></td> <td></td></tr> <tr><td><code>sequence</code></td> <td><code>clauses</code></td> <td><code>clauses[0] ...</code></td> <td></td></tr> <tr><td><code>tags</code></td> <td><code>name</code>[,<code>attributes</code>,<code>adjust</code>,<code>capture</code>]</td> <td><code>&lt;name att0key=&quot;att0value&quot; ... /&gt;</code><br><code>&lt;name&gt;</code><br><code>&lt;/name&gt;</code><br><code>capture:&lt;name/&gt;</code></td> <td></td></tr></tbody></table> <p>The following should never be produced by parsing a CorpusQL query, but are still available if needed:</p> <table tabindex="0"><thead><tr><th><code>type</code></th> <th>properties</th> <th>CorpusQL equivalent</th> <th>Notes</th></tr></thead> <tbody><tr><td><code>edge</code></td> <td><code>clause</code>,<code>trailingEdge</code></td> <td>(none)</td> <td>Returm leading edge of <code>clause</code> if <code>trailingEdge</code> is false, trailing edge otherwise.</td></tr> <tr><td><code>expansion</code></td> <td><code>clause</code>,<code>direction</code>,<code>min</code>[,<code>max</code>]</td> <td>e.g. <code>clause []{min,max}</code></td> <td><code>max</code> omitted if there is no limit</td></tr> <tr><td><code>filterngrams</code></td> <td></td> <td></td> <td>Used for optimization of certain queries, e.g. <code>[]{2,3} within &lt;s/&gt;</code>.</td></tr> <tr><td><code>fixedspan</code></td> <td></td> <td></td> <td>Used to get a specific span from <code>start</code> to <code>end</code></td></tr> <tr><td><code>term</code></td> <td></td> <td></td> <td>Terms in CorpusQL queries are always parsed as regexes.</td></tr></tbody></table> <h2 id="todo" tabindex="-1">TODO <a class="header-anchor" href="#todo" aria-label="Permalink to &quot;TODO&quot;">​</a></h2> <ul><li>Document JSON query structure (probably on a separate page)</li></ul>`,55)]))}const u=t(d,[["render",n]]);export{k as __pageData,u as default};
