import{_ as t,c as o,o as r,al as a}from"./chunks/framework.B3j7FRen.js";const m=JSON.parse('{"title":"Find hits / group hits","description":"","frontmatter":{},"headers":[],"relativePath":"server/rest-api/corpus/hits/get.md","filePath":"server/030_rest-api/_corpus/hits/get.md","lastUpdated":1749639304000}'),d={name:"server/rest-api/corpus/hits/get.md"};function s(i,e,c,n,l,u){return r(),o("div",null,e[0]||(e[0]=[a(`<h1 id="find-hits-group-hits" tabindex="-1">Find hits / group hits <a class="header-anchor" href="#find-hits-group-hits" aria-label="Permalink to &quot;Find hits / group hits&quot;">​</a></h1> <p>Find occurrences of a text pattern in the corpus, optionally filtered on document metadata fields.</p> <p>This resource can also group hits (returning a list of groups), or show the contents of one of the resulting groups.</p> <p>This is generally the most-used endpoint for BlackLab Server, and includes the most features.  For a more gentle introduction, see the <a href="/server/overview.html">overview</a>.</p> <p><strong>URL</strong> : <code>/blacklab-server/&lt;corpus-name&gt;/hits</code></p> <p><strong>Method</strong> : <code>GET</code></p> <p>All parameters except <code>patt</code> are optional.</p> <h4 id="basic-parameters" tabindex="-1">Basic parameters <a class="header-anchor" href="#basic-parameters" aria-label="Permalink to &quot;Basic parameters&quot;">​</a></h4> <p>Use these to find text patterns in the corpus and control which results are returned.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>patt</code></td> <td><a href="/guide/query-language/">BlackLab Corpus Query Language</a> (BCQL) pattern to search for</td></tr> <tr><td><code>filter</code></td> <td><a href="https://lucene.apache.org/core/8_8_1/queryparser/org/apache/lucene/queryparser/classic/package-summary.html#package.description" target="_blank" rel="noreferrer">Lucene Query Language</a> document filter query</td></tr> <tr><td><code>context</code></td> <td>(formerly <code>wordsaroundhit</code>) how much context to return around hits. Examples: <code>5</code> gives 5 words around hit, <code>5:10</code> gives 5 before and 10 after, <code>s</code> returns full sentences (if <code>s</code> is an inline tag in your data). Default: <code>5</code></td></tr> <tr><td><code>first</code></td> <td>first result (0-based) to return with this request. Use this to get a page of results from the total set. Default: <code>0</code></td></tr> <tr><td><code>number</code></td> <td>number of results to return (if available) with this request. Use this to get a page of results from the total set. Default: <code>50</code>.<br><strong>NOTE:</strong> this value is limited by the <a href="/server/configuration.html#complete-config-file"><code>parameters.pageSize.max</code> setting</a> in <code>blacklab-server.yaml</code>.<br><strong>NOTE2:</strong> if you are only interested in the total number of results, not the results themselves, set this to 0. The total number of results will be in the response as <code>summary.numberOfHits</code>.</td></tr></tbody></table> <h4 id="parameters-for-sampling" tabindex="-1">Parameters for sampling <a class="header-anchor" href="#parameters-for-sampling" aria-label="Permalink to &quot;Parameters for sampling&quot;">​</a></h4> <p>Take a random sampling of hits. Note that this has to retrieve all hits (or at least as many hits as the <code>maxretrieve</code> setting allows), then perform the sampling, so it may take a while.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>sample</code></td> <td>Percentage of hits to select. Chooses a random sample of all the hits found.</td></tr> <tr><td><code>samplenum</code></td> <td>Exact number of hits to select. Chooses a random sample of all the hits found.</td></tr> <tr><td><code>sampleseed</code></td> <td>Signed long seed number for sampling. If given, uses this value to seed the random number generator, ensuring identical sampling results next time. Please note that, without sorting, hit order is undefined (if the same data is re-indexed, hits may be produced in a different order). So if you want true reproducability, you should always sort hits that you want to sample, ideally with multiple sort criteria so the sort is fully defined.</td></tr></tbody></table> <h4 id="parameters-for-sorting-and-grouping-hits-and-faceting-documents" tabindex="-1">Parameters for sorting and grouping hits and faceting documents <a class="header-anchor" href="#parameters-for-sorting-and-grouping-hits-and-faceting-documents" aria-label="Permalink to &quot;Parameters for sorting and grouping hits and faceting documents&quot;">​</a></h4> <p>Hits can be grouped by various criteria (see below). Faceting can be performed on the matching documents.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>sort</code></td> <td>One or more sort criteria, for example: <code>hit:word:s</code> to sort by matched words, case-sensitively. Detailed explanation below.</td></tr> <tr><td><code>group</code></td> <td>One or more grouping criteria, for example: <code>before:lemma:i:1</code> to group on the lemma before the matched words, case-insensitively. Detailed explanation below.</td></tr> <tr><td><code>includegroupcontents</code></td> <td>Whether to include the hits with each group.<br><strong>NOTE:</strong> only works for <code>/hits</code> requests for now. Default: <code>false</code></td></tr> <tr><td><code>viewgroup</code></td> <td>Identity of one of the groups to view (<code>identity</code> values are returned with the grouping results).<br><strong>NOTE:</strong> may not return all hits in the group because there is a limit to how many are stored. Use <code>hitfiltercrit</code>/<code>hitfilterval</code> to get all hits.</td></tr> <tr><td><code>hitfiltercrit</code> and <code>hitfilterval</code></td> <td>Filter hits by a criterium and value. See below.</td></tr> <tr><td><code>facets</code></td> <td>Document faceting criteria, comma-separated. For example: <code>field:author</code> to facet matched documents by author. Detailed explanation below.</td></tr></tbody></table> <details class="details custom-block"><summary><b>The <code>hitfiltercrit</code> / <code>hitfilterval</code> parameters explained</b></summary> <p>These parameters can be used to view all hits in a &quot;group&quot;, and even perform another grouping on the results. For example: <code>after:pos:i:1</code> to filter hits by the <code>pos</code> value directly following the hit, case-insensitively. Detailed explanation below. Also needs <code>hitfilterval</code> (the value to keep when filtering) to work.</p> <p>This is useful if you want to view hits in a group, and then be able to group on those hits again. These two parameters essentially do something similar to the <code>viewgroup</code> parameter: that parameter also allows you to view the hits in a group, but won&#39;t allow you to group that subset of hits again. By specifying multiple criteria and values to <code>hitfiltercrit</code>/<code>hitfilterval</code>, you can keep diving deeper into your result set.</p> <p>Note that this may be slow at present because it finds all hits, then filters them by this criterium.</p> <p>(TECHNICAL NOTE: performance could be improved by internally extending the specified <code>patt</code> with the <code>hitfiltercrit</code>/<code>hitfilterval</code> so we only find the matches we&#39;re interested in. This requires the use of lookahead/lookbehind, which we have working now).</p></details> <div class="warning custom-block"><p class="custom-block-title">PLEASE NOTE</p> <p><code>sort</code>, <code>group</code> and <code>hitfiltercrit</code>/<code>hitfilterval</code> all require all results to be retrieved (or at least as much as allowed by the <code>maxretrieve</code> value), so they may take a lot of time and memory.</p></div> <p>Criteria for sorting, grouping and faceting are explained in &quot;Criteria for sorting, grouping and faceting&quot; below.</p> <h4 id="criteria-for-sorting-grouping-and-faceting" tabindex="-1">Criteria for sorting, grouping and faceting <a class="header-anchor" href="#criteria-for-sorting-grouping-and-faceting" aria-label="Permalink to &quot;Criteria for sorting, grouping and faceting&quot;">​</a></h4> <p>The <code>sort</code>, <code>group</code>, <code>hitfiltercrit</code> and <code>facets</code> parameters receive one or more criteria (comma-separated) that indicate what to sort, group, filter or facet on.</p> <p>These are the basic criteria:</p> <table tabindex="0"><thead><tr><th>Criterium</th> <th>Meaning</th></tr></thead> <tbody><tr><td><code>field:<em>name</em></code></td> <td>Metadata field. Example: <code>field:author</code></td></tr> <tr><td><code>decade:<em>name</em></code></td> <td>Sort/group by the decade of the year given in specified metadata field (rounds the value of the field down to the nearest multiple of 10, so <code>1976</code> becomes <code>1970</code>).</td></tr> <tr><td><code>identity</code></td> <td>(for sorting results of a grouping request) Sort by group identity.</td></tr> <tr><td><code>size</code></td> <td>(for sorting results of a grouping request) Sort by group size, descending by default.</td></tr></tbody></table> <p>Any sort criterium can be reversed by prefixing it with a dash, e.g. <code>-field:year</code> to sort by the <code>year</code> field, descending. If multiple properties are combined with commas, each may be individually reversed or not, e.g. <code>-prop1,prop2,-prop3</code> to only reverse <code>prop1</code> and <code>prop3</code>. It is also possible to reverse all properties together: <code>-(prop1,prop2,prop3)</code>.</p> <p>In addition to the basic criteria, it is also possible to sort/group on context words, such as the words matched by your query, or the words before or after the matched words:</p> <table tabindex="0"><thead><tr><th>Criterium</th> <th>Meaning</th></tr></thead> <tbody><tr><td><code>hit:<em>annot</em>:<em>c</em></code></td> <td>Sort/group/facet on matched text. If <code>annot</code> is omitted, the default annotation (usually <code>word</code>) is used. <code>c</code> can specify case-sensitivity: either <code>s</code> (sensitive) or <code>i</code> (insensitive). Examples: <code>hit</code>, <code>hit:lemma</code>, <code>hit:lemma:s</code>.</td></tr> <tr><td><code>before:<em>annot</em>:<em>c</em>:<em>n</em></code><br><code>left:<em>annot</em>:<em>c</em>:<em>n</em></code></td> <td>Context words before the hit (if number <code>n</code> not specified, uses default before-hit context size). For grouping, you might use <code>n==1</code>, and for sorting a larger value (or the default, usually <code>5</code>) might be more suitable. Examples: <code>before</code>, <code>before:pos</code>, <code>before:pos:s</code>, <code>before:pos:s:3</code></td></tr> <tr><td><code>after:<em>annot</em>:<em>c</em>:<em>n</em></code><br><code>right:<em>annot</em>:<em>c</em>:<em>n</em></code></td> <td>Context words after the hit (if number <code>n</code> not specified, uses default after-hit context size). For grouping, you might use <code>n==1</code>, and for sorting a larger value (or the default, usually <code>5</code>) might be more suitable. Examples: <code>after</code>, <code>after:pos</code>, <code>after:pos:s</code>, <code>after:pos:s:3</code></td></tr> <tr><td><code>wordleft:<em>annot</em>:<em>c</em></code></td> <td>Single word of before-context. Deprecated, use <code>before:<em>annot</em>:<em>c</em>:1</code> instead.</td></tr> <tr><td><code>wordright:<em>annot</em>:<em>c</em></code></td> <td>Single word of after-context. Deprecated, use <code>after:<em>annot</em>:<em>c</em>:1</code> instead.</td></tr> <tr><td><code>context:<em>annot</em>:<em>c</em>:<em>spec</em></code></td> <td>More generic context words expression, giving the user more control at the cost of a bit of speed. Example: <code>context:word:s:H1-2</code> (first two matched words). See below for a complete specification.</td></tr> <tr><td><code>capture:<em>annot</em>:<em>c</em>:<em>groupname</em></code><br><code>capture:<em>annot</em>:<em>c</em>:<em>groupname</em>:<em>spanmode</em></code></td> <td>Contents of a named capture group in your text pattern. Example: <code>capture:word:s:PERSON</code> for the contents of the capture group named <code>PERSON</code> (your pattern might be <code>&quot;talk&quot; &quot;to&quot; PERSON:[]</code>). <br><br>When grouping by matched (dependency) relations, (i.e. with query <code>_ -nsubj-&gt; _</code> to find subject relations), you can add <code>source</code> or <code>target</code> as the <code>spanmode</code> to group by either the source or target of the relation (default <code>spanmode</code> is <code>full</code>, which for relations spans both source and target).</td></tr> <tr><td><code>span-attribute:<em>spanName</em>:<em>attribute</em>:<em>c</em></code><br></td> <td>Attribute of a span captured by your query. Example: <code>span-attribute:speech:lang:c</code> for the contents of the span named <code>speech</code> (your pattern might be <code>&quot;test&quot; within &lt;speech /&gt;</code>).</td></tr> <tr><td><code>alignments</code><br></td> <td>Sort by number of alignments found in a parallel corpus. Hits with the most alignments are sorted at the top.</td></tr></tbody></table> <details class="details custom-block"><summary><b>The <code>context</code> criterium explained</b></summary> <p>Criteria like <code>context:word:s:H1-2</code> (&quot;the first two matched words&quot;) allow fine control over what to group or sort on.</p> <p>Like with criteria such as <code>left</code>, <code>right</code> or <code>hit</code>, you can vary the annotation to group or sort on (e.g. <code>word</code>/<code>lemma</code>/<code>pos</code>, or whatever annotations your data set has). You may specify whether to sort/group case- and accent-sensitively (<code>s</code>) or insensitively (<code>i</code>).</p> <p>The final parameter to a <code>context</code> criterium is the &quot;specification&quot;. This consists of one or more parts separated by a semicolon. Each part consists of an &quot;anchor&quot; (starting point) and number(s) to indicate a stretch of words. The anchor can be <code>H</code> (hit text), <code>E</code> (hit text, but counted from the end of the hit backwards), <code>L</code> (words to the left of the hit) or <code>R</code> (words to the right of the hit). The number or numbers after the anchor specify what words you want from this part. A single number indicates a single word; <code>1</code> is the first word, <code>2</code> the second word, etc. So <code>E2</code> means &quot;the second-to-last word of the hit&quot;. Two numbers separated by a dash indicate a stretch of words. So <code>H1-2</code> means &quot;the first two words of the hit&quot;, and <code>E2-1</code> means &quot;the second-to-last word followed by the last word&quot;. A single number followed by a dash means &quot;as much as possible from this part, starting from this word&quot;. So <code>H2-</code> means &quot;the entire hit text except the first word&quot;.</p> <p>A few more examples:</p> <ul><li><code>context:word:s:H1;E1</code>: the first and last matched word)</li> <li><code>context:word:s:A2-3</code>: second and third word after the match)</li> <li><code>context:word:s:B1-</code>: words before the match, starting from first word before the match, i.e. the same as <code>before:word:s</code>. How many words of context are used depends on the <code>context</code> parameter (default: 5)</li></ul></details> <details class="details custom-block"><summary>Parallel corpora and grouping/sorting on context</summary> <p>In parallel corpora, you can prefix the annotation name with the version or field name and a <code>%</code> to specify what version you&#39;re referring to.</p> <p>For example, if your parallel corpus has versions <code>en</code> and <code>nl</code>, you can
specify <code>hit:en%word:s</code> to sort/group on the English version of the matched
text, or <code>before:nl%word:s:1</code> to sort/group on the Dutch version of the word.</p> <p>You may also use the full field name, e.g. <code>hit:contents__en%word:s</code> or <code>before:contents__nl%word:s:1</code>.</p></details> <h4 id="miscellaneous-parameters" tabindex="-1">Miscellaneous parameters <a class="header-anchor" href="#miscellaneous-parameters" aria-label="Permalink to &quot;Miscellaneous parameters&quot;">​</a></h4> <p>Some less commonly used parameters for advanced use cases.</p> <table tabindex="0"><thead><tr><th>Parameter</th> <th>Description</th></tr></thead> <tbody><tr><td><code>waitfortotal</code></td> <td>Whether or not to wait for the total number of results to be known. If no (the default), subsequent requests (with number=0 if you don’t need more hits) can be used to monitor the total count progress. Default: <code>false</code></td></tr> <tr><td><code>listvalues</code></td> <td>Comma-separated list of annotation names to return for each result. By default, all annotations are included.</td></tr> <tr><td><code>field</code></td> <td>the annotated field to search using <code>patt</code>, if your corpus contains multiple annotated fields. Most corpora only contain one. Defaults to the first (or only) annotated field defined. (NOTE: for a parallel corpus, if you only specify a version, e.g. <code>en</code>, BlackLab will automatically use the <code>contents__en</code> field if that exists)</td></tr> <tr><td><code>pattlang</code></td> <td>pattern language to use for <code>patt</code>. Defaults to <code>bcql</code> (BlackLab Corpus Query Language). The other values (<code>contextql</code> and <code>luceneql</code>) have very limited support at the moment.  Other, more useful query languages may be added in the future.</td></tr> <tr><td><code>pattgapdata</code></td> <td>Data (TSV, tab-separated values) to put in gaps in query. Explained below.</td></tr> <tr><td><code>filterlang</code></td> <td>filter language to use for <code>filter</code>. Defaults to <code>luceneql</code>. <code>contextql</code> is also supported, but very limited. More options may be added in the future.</td></tr> <tr><td><code>docpid</code></td> <td>filter on a single document pid.</td></tr> <tr><td><code>maxretrieve</code></td> <td>Maximum number of hits to retrieve. <code>-1</code> means &quot;no limit&quot;. Also affects documents-containing-pattern queries and grouped-hits queries. Default and maximum allowed value configurable. Very large values (millions, or unlimited) may cause server problems.</td></tr> <tr><td><code>maxcount</code></td> <td>Maximum number of hits to count. <code>-1</code> means &quot;no limit&quot;. Default and maximum allowed value configurable. Even when BlackLab stops retrieving hits, it still keeps counting them. For large results sets this may take a long time.</td></tr> <tr><td><code>usecontent</code></td> <td><code>fi</code> or <code>orig</code>. <code>fi</code> (default) uses the forward index to reconstruct document content (for snippets and concordances; inline tags are lost in the process), <code>orig</code> uses the original XML from the content store (slower but more accurate).<br><strong>NOTE:</strong> using the original content may cause problems with well-formedness; these are fixed automatically, but the fix may result in inline tags in strange places (e.g. a start-sentence tag that is not at the start of the sentence anymore)</td></tr> <tr><td><code>escapexmlfragment</code></td> <td>when using <code>usecontent=orig</code> and XML response, should fragments be escaped as CDATA or not? Default: <code>false</code> for API v4 and older, <code>true</code> for v5+.</td></tr> <tr><td><code>calc</code></td> <td>specify the value <code>colloc</code> to calculate collocations (frequency lists of words near hits). Experimental feature.</td></tr> <tr><td><code>omitemptycaptures</code></td> <td>if true, will omit capture groups of length 0 (default <code>false</code>, configurable in blacklab-server.yaml)</td></tr> <tr><td><code>withspans</code></td> <td>capture a list (named <code>with-spans</code>) of all spans overlapping each hit (e.g. this might contain the relevant sentence, paragraph and chapter spans if you&#39;ve indexed those)</td></tr> <tr><td><code>adjusthits</code></td> <td>(relations queries only) should query hits be adjusted so all matched relations are inside the hit? Default: <code>no</code></td></tr></tbody></table> <details class="details custom-block"><summary><b>The <code>pattgapdata</code> parameter explained</b></summary> <p>You may leave &#39;gaps&#39; in the double-quoted strings in your BCQL query that can be filled in from tabular data. The gaps should be denoted by <code>@@</code>, e.g. <code>[lemma=&quot;@@&quot;]</code> or <code>[word=&quot;@@cat&quot;]</code>. For each row in your TSV data, will fill in the row data in the gaps. The queries resulting from all the rows are combined using OR. For example, if your query is <code>&quot;The&quot; &quot;@@&quot; &quot;@@&quot;</code> and your TSV data is <code>white\\tcat\\nblack\\tdog</code>, this will execute the query <code>(&quot;The&quot; &quot;white&quot; &quot;cat&quot;) | (&quot;The&quot; &quot;black&quot; &quot;dog&quot;)</code>. Please note that if you want to pass a large amount of data, you should use a <code>POST</code> request as the amount of data you can pass in a <code>GET</code> request is limited.</p></details> <h2 id="success-response" tabindex="-1">Success Response <a class="header-anchor" href="#success-response" aria-label="Permalink to &quot;Success Response&quot;">​</a></h2> <p><strong>Code</strong> : <code>200 OK</code></p> <h3 id="content-examples" tabindex="-1">Content examples <a class="header-anchor" href="#content-examples" aria-label="Permalink to &quot;Content examples&quot;">​</a></h3> <p>TODO</p> <div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div><h2 id="todo" tabindex="-1">TODO <a class="header-anchor" href="#todo" aria-label="Permalink to &quot;TODO&quot;">​</a></h2> <ul><li>This endpoint does a lot of different things, producing different responses. This can be confusing. We could consider moving the grouping operations to one or more new endpoints.</li></ul>`,76)]))}const p=t(d,[["render",s]]);export{m as __pageData,p as default};
