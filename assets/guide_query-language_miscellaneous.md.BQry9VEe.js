import{_ as t,c as o,o as d,al as a}from"./chunks/framework.B3j7FRen.js";const h=JSON.parse('{"title":"Miscellaneous","description":"","frontmatter":{},"headers":[],"relativePath":"guide/query-language/miscellaneous.md","filePath":"guide/040_query-language/050_miscellaneous.md","lastUpdated":1749639304000}'),c={name:"guide/query-language/miscellaneous.md"};function r(n,e,s,i,u,l){return d(),o("div",null,e[0]||(e[0]=[a(`<h1 id="miscellaneous" tabindex="-1">Miscellaneous <a class="header-anchor" href="#miscellaneous" aria-label="Permalink to &quot;Miscellaneous&quot;">​</a></h1> <h2 id="operator-precedence" tabindex="-1">Operator precedence <a class="header-anchor" href="#operator-precedence" aria-label="Permalink to &quot;Operator precedence&quot;">​</a></h2> <p>This is the precedence of the different BCQL operators, from highest to lowest. The highest precedence operators &quot;bind
most tightly&quot;. See the examples below.</p> <p>Inside token brackets <code>[ ]</code>:</p> <table tabindex="0"><thead><tr><th>Operator</th> <th>Description</th> <th>Associativity</th></tr></thead> <tbody><tr><td><code>!</code></td> <td>logical not</td> <td>right-to-left</td></tr> <tr><td><code>=</code> <code>!=</code></td> <td>(not) equals</td> <td>left-to-right</td></tr> <tr><td><code>&amp;</code> <code>|</code></td> <td>logical and/or</td> <td>left-to-right</td></tr></tbody></table> <p>At the sequence level (i.e. outside token brackets):</p> <table tabindex="0"><thead><tr><th>Operator</th> <th>Description</th> <th>Associativity</th></tr></thead> <tbody><tr><td><code>!</code></td> <td>logical not</td> <td>right-to-left</td></tr> <tr><td><code>[ ]</code></td> <td>token brackets</td> <td>left-to-right</td></tr> <tr><td><code>( )</code></td> <td>function call</td> <td>left-to-right</td></tr> <tr><td><code>*</code> <code>+</code> <code>?</code><br><code>{n}</code> <code>{n,m}</code></td> <td>repetition</td> <td>left-to-right</td></tr> <tr><td><code>:</code></td> <td>capture</td> <td>right-to-left</td></tr> <tr><td><code>&lt; /&gt;</code> <code>&lt; &gt;</code> <code>&lt;/ &gt;</code></td> <td>span (start/end)</td> <td>left-to-right</td></tr> <tr><td><code>[] []</code></td> <td>sequence<br>(implied operator)</td> <td>left-to-right</td></tr> <tr><td><code>|</code> <code>&amp;</code></td> <td>union/intersection</td> <td>left-to-right</td></tr> <tr><td><code>--&gt; [ ; --&gt; ]</code><br><code>^--&gt;</code><br><code>==&gt; [ ; ==&gt; ]</code></td> <td>child relations<br>root relation<br>alignment</td> <td>right-to-left</td></tr> <tr><td><code>within</code> <code>containing</code></td> <td>position filter</td> <td>right-to-left</td></tr> <tr><td><code>::</code></td> <td>capture constraint</td> <td>left-to-right</td></tr></tbody></table> <p>NOTES:</p> <ul><li>you can always use grouping parens <code>( )</code> (at either token or sequence level) to override this precedence.</li> <li>notice that <code>|</code> and <code>&amp;</code> have the <em>same</em> precedence; don&#39;t rely on <code>&amp;</code> binding more tightly than <code>|</code> or vice versa, which you might be used to from other languages.</li></ul> <p>A few examples:</p> <table tabindex="0"><thead><tr><th>Query</th> <th>Interpreted as</th></tr></thead> <tbody><tr><td><code>[word = &quot;can&quot; &amp; pos != &quot;verb&quot;]</code></td> <td><code>[ (word = &quot;can&quot;) &amp; (pos != &quot;verb&quot;) ]</code></td></tr> <tr><td><code>[pos = &quot;verb&quot; | pos = &quot;noun&quot; &amp; word = &quot;can&quot;]</code></td> <td><code>[ (pos = &quot;verb&quot; | pos = &quot;noun&quot;) &amp; word = &quot;can&quot;]</code></td></tr> <tr><td><code>A:&quot;very&quot;+</code></td> <td><code>A:(&quot;very&quot;+)</code></td></tr> <tr><td><code>A:_ --&gt; B:_</code></td> <td><code>(A:_) --&gt; (B:_)</code></td></tr> <tr><td><code>_ -obj-&gt; _ -amod-&gt; _</code></td> <td><code>_ -obj-&gt; (_ -amod-&gt; _)</code></td></tr> <tr><td><code>!&quot;d.*&quot; &amp; &quot;.e.*&quot;</code></td> <td><code>(!&quot;d.*&quot;) &amp; &quot;.e.*&quot;</code>, meaning <br><code>[word != &quot;d.*&quot; &amp; word = &quot;.e.*&quot;]</code></td></tr> <tr><td><code>&quot;cow&quot; within &lt;pasture/&gt; containing &quot;grass&quot;</code></td> <td><code>&quot;cow&quot; within (&lt;pasture/&gt; containing &quot;grass&quot;)</code></td></tr></tbody></table> <h2 id="cql-support-differences" tabindex="-1">CQL support, differences <a class="header-anchor" href="#cql-support-differences" aria-label="Permalink to &quot;CQL support, differences&quot;">​</a></h2> <p>For those who already know CQL/CQP from another corpus search engine such as IMS Corpus Workbench, here&#39;s a quick overview of the extent of BlackLab&#39;s support for this &quot;lingua franca&quot; corpus query language. If a feature we don&#39;t support yet is important to you, please let us know. If it&#39;s quick to add, we may be able to help you out.</p> <h3 id="supported-features" tabindex="-1">Supported features <a class="header-anchor" href="#supported-features" aria-label="Permalink to &quot;Supported features&quot;">​</a></h3> <p>BlackLab currently supports (arguably) most of the important features of Corpus Query Language:</p> <ul><li>Matching on token annotations, using regular expressions and <code>=</code>, <code>!=</code>, <code>!</code>. Example: <code>[word=&quot;bank&quot;]</code> (or just <code>&quot;bank&quot;</code>)</li> <li>Case/accent sensitive matching. Note that, unlike in CWB, case-INsensitive matching is the default. To explicitly match case-/accent-insensitively, use <code>&quot;(?i)...&quot;</code>. Example: <code>&quot;(?-i)Mr\\.&quot; &quot;(?-i)Banks&quot;</code></li> <li>Combining criteria using <code>&amp;</code>, <code>|</code> and <code>!</code>. Parentheses can also be used for grouping. Example: <code>[lemma=&quot;bank&quot; &amp; pos=&quot;V&quot;]</code></li> <li>Matchall pattern <code>[]</code> matches any token. Example: <code>&quot;a&quot; [] &quot;day&quot;</code></li> <li>Regular expression operators <code>+</code>, <code>*</code>, <code>?</code>, <code>{n}</code>, <code>{n,m}</code> at the token level. Example: <code>[pos=&quot;ADJ&quot;]+</code></li> <li>Sequences of token constraints. Example: <code>[pos=&quot;ADJ&quot;] &quot;cow&quot;</code></li> <li>Operators <code>|</code>, <code>&amp;</code> and parentheses can be used to build complex sequence queries. Example: <code>&quot;happy&quot; &quot;dog&quot; | &quot;sad&quot; &quot;cat&quot;</code></li> <li>Querying with tag positions using e.g. <code>&lt;s&gt;</code> (start of sentence), <code>&lt;/s&gt;</code> (end of sentence), <code>&lt;s/&gt;</code> (whole sentence) or <code>&lt;s&gt; ... &lt;/s&gt;</code> (equivalent to <code>&lt;s/&gt; containing ...</code>). Example: <code>&lt;s&gt; &quot;The&quot; </code>. XML attribute values may be used as well, e.g. <code>&lt;ne type=&quot;PERS&quot;/&gt;</code> (&quot;named entities that are persons&quot;).</li> <li>Using <code>within</code> and <code>containing</code> operators to find hits inside another set of hits. Example: <code>&quot;you&quot; &quot;are&quot; within &lt;s/&gt;</code></li> <li>Using an anchor to capture a token position. Example: <code>&quot;big&quot; A:[]</code>. Captured matches can be used in capture
constraints (see next item) or processed separately later (using the Java interface; capture information is not yet returned by BlackLab Server). Note that BlackLab can actually capture entire groups of tokens as well, similarly to regular expression engines.</li> <li>Capture constraints, such as requiring two captures to contain the same word. Example: <code>&quot;big&quot; A:[] &quot;or&quot; &quot;small&quot; B:[] :: A.word = B.word</code></li></ul> <p>See below for features not in this list that may be added soon, and let us know if you want a particular feature to be added.</p> <h3 id="differences-from-cwb" tabindex="-1">Differences from CWB <a class="header-anchor" href="#differences-from-cwb" aria-label="Permalink to &quot;Differences from CWB&quot;">​</a></h3> <p>BlackLab&#39;s CQL syntax and behaviour differs in a few ways from CWBs, although they are mostly lesser-used features.</p> <p>For now, here&#39;s what you should know:</p> <ul><li>Case-insensitive search is the default in BlackLab, while CWB and Sketch Engine use case-sensitive search as the default. If you want to match a term case-sensitively, use <code>&quot;(?-i)..&quot;</code> or <code>&quot;(?c)..&quot;</code>.</li> <li>If you want to match a string literally, not as a regular expression, use backslash escaping (<code>&quot;e\\.g\\.&quot;</code>) or a literal string (<code>l&quot;e.g.&quot;</code>)</li> <li>BlackLab supports result set manipulation such as: sorting (including on specific context words), grouping/frequency distribution, subsets, sampling, setting context size, etc. However, these are supported through the REST and Java APIs, not through a command interface like in CWB. See <a href="/server/overview.html">BlackLab Server overview</a>).</li> <li>Querying XML elements and attributes looks natural in BlackLab: <code>&lt;s/&gt;</code> means &quot;sentences&quot;, <code>&lt;s&gt;</code> means &quot;starts of sentences&quot;, <code>&lt;s type=&quot;A&quot;&gt;</code> means &quot;sentence tags with a type attribute with value A&quot;. This natural syntax differs from CWBs in some places, however, particularly when matching XML attributes.</li> <li>In capture constraints (expressions occurring after <code>::</code>), only literal matching (no regex matching) is currently supported.</li> <li>To return whole sentences as the context of hits, pass <code>context=s</code> to BLS.</li> <li>The implication operator <code>-&gt;</code> is currently only supported in capture constraints (expressions after the <code>::</code> operator), not in a regular token constraints.</li> <li>We don&#39;t support the <code>@</code> anchor and corresponding <code>target</code> label; use a named anchor instead.</li> <li>backreferences to anchors only work in capture constraints, so this doesn&#39;t work: <code>A:[] [] [word = A.word]</code>. Instead, use something like: <code>A:[] [] B:[] :: A.word = B.word</code>.</li> <li>Instead of CWBs <code>intersection</code>, <code>union</code> and <code>difference</code> operators, BlackLab supports the <code>&amp;</code>, <code>|</code> and <code>!</code> operators at the top-level of the query, e.g. <code>(&quot;double&quot; [] &amp; [] &quot;trouble&quot;)</code> to match the intersection of these queries, i.e. &#39;double trouble&#39; and <code>(&quot;happy&quot; &quot;dog&quot; | &quot;sad&quot; &quot;cat&quot;)</code> to match the union of &#39;happy dog&#39; and &#39;sad cat&#39;. Difference can be achieved by combining <code>!</code> and <code>&amp;</code>, e.g. <code>(&quot;happy&quot; [] &amp; !([] &quot;dog&quot;))</code> to match &#39;happy&#39; followed by anything except &#39;dog&#39; (although this is better expressed as <code>&quot;happy&quot; [word != &quot;dog&quot;]</code>).</li> <li>Integer ranges are supported: <code>[pos=&quot;verb&quot; &amp; pos_confidence=in[50,100]]</code> or <code>&lt;verse number=in[1,10]/&gt;</code> (ranges are always inclusive)</li></ul> <h3 id="currently-unsupported" tabindex="-1">(Currently) unsupported <a class="header-anchor" href="#currently-unsupported" aria-label="Permalink to &quot;(Currently) unsupported&quot;">​</a></h3> <p>Some CWB features that are not (yet) supported in BlackLab:</p> <ul><li><code>lbound</code>, <code>rbound</code> functions to get the edge of a region. You can use <code>&lt;s&gt;</code> to get all starts-of-sentences or <code>&lt;/s&gt;</code> to get all ends-of-sentences, however.</li> <li><code>distance</code>, <code>distabs</code> functions and <code>match</code>, <code>matchend</code> anchor points (sometimes used in capture constraints).</li> <li>using an XML element name to mean &#39;token is contained within&#39;, like <code>[(pos = &quot;N&quot;) &amp; !np]</code> meaning &quot;noun NOT inside in an <code>&lt;np/&gt;</code> tag&quot;.</li> <li>a number of less well-known features.</li></ul> <p>If people ask about missing features, we&#39;re happy to work with them to see if it could be added.</p>`,49)]))}const q=t(c,[["render",r]]);export{h as __pageData,q as default};
