import{_ as e,c as s,o as t,al as i}from"./chunks/framework.B3j7FRen.js";const u=JSON.parse(`{"title":"Example XPaths","description":"Contains examples that we link to sometimes, but aren't in the main doc navs","frontmatter":{"excludeFromSidebar":true,"description":"Contains examples that we link to sometimes, but aren't in the main doc navs"},"headers":[],"relativePath":"guide/index-your-data/xpath-examples.md","filePath":"guide/030_index-your-data/_xpath-examples.md","lastUpdated":1749639304000}`),n={name:"guide/index-your-data/xpath-examples.md"};function l(o,a,p,r,h,d){return t(),s("div",null,a[0]||(a[0]=[i(`<h1 id="example-xpaths" tabindex="-1">Example XPaths <a class="header-anchor" href="#example-xpaths" aria-label="Permalink to &quot;Example XPaths&quot;">​</a></h1> <p><a href="./miscellaneous.html#xpath-support-level">When using <code>processor: saxon</code></a>,
you have extensive possibilities using XPath in BlackLab input format configurations. Some noteworthy examples are shown below.</p> <p>To learn more about modern XPath, <a href="https://www.altova.com/training/xpath3" target="_blank" rel="noreferrer">Altova&#39;s XPath 3 training</a> is a good resource, and there are many others.</p> <h2 id="capture-punctuation-between-words" tabindex="-1">Capture punctuation between words <a class="header-anchor" href="#capture-punctuation-between-words" aria-label="Permalink to &quot;Capture punctuation between words&quot;">​</a></h2> <p>To capture text content between <code>&lt;w/&gt;</code> tags:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">punctPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.//text()[not(ancestor::w)]</span></span></code></pre></div><p>This captures any text node that is not a descendant of a <code>&lt;w/&gt;</code> tag.</p> <p>Another possible approach:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">punctPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.//text()[.!=&#39;&#39; and preceding-sibling::tei:w]|.//tei:pc |.//tei:lb</span></span></code></pre></div><p>This captures non-empty text nodes after a <code>&lt;w/&gt;</code> tag plus (the text contents of) <code>pc</code> or <code>lb</code> tags.</p> <h2 id="isolate-a-part-of-speech-feature" tabindex="-1">Isolate a part of speech feature <a class="header-anchor" href="#isolate-a-part-of-speech-feature" aria-label="Permalink to &quot;Isolate a part of speech feature&quot;">​</a></h2> <p>Your data may have part of speech information that includes detailed features. Let&#39;s say this information is stored in an attribute with values like <code>UPosTag=PRON|Case=Nom|Person=3|PronType=Prs</code>. You can isolate the value of the <code>Case</code> feature like this:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">valuePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">replace(./@msd, &#39;.*Case=([A-Za-z0-9]+).*&#39;, &#39;$1&#39;)</span></span></code></pre></div><h2 id="use-default-if-value-is-missing" tabindex="-1">Use default if value is missing <a class="header-anchor" href="#use-default-if-value-is-missing" aria-label="Permalink to &quot;Use default if value is missing&quot;">​</a></h2> <p>If some of your words have a lemma attribute, and you want to index the value <code>_UNKNOWN_</code> if it&#39;s missing (perhaps to be able to locate these data problems easily), you can do that as follows:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">valuePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">./(string(@lemma), &#39;_UNKNOWN_&#39;)[1]</span></span></code></pre></div><h2 id="using-either-an-attribute-or-a-standoff-annotation" tabindex="-1">Using either an attribute, or a standoff annotation <a class="header-anchor" href="#using-either-an-attribute-or-a-standoff-annotation" aria-label="Permalink to &quot;Using either an attribute, or a standoff annotation&quot;">​</a></h2> <p>Again, let&#39;s say some of your words have <code>lemma</code> attributes. But some have the lemma in a separate <code>tei:join</code> element instead. You might use XPath to look up the appropriate value like this:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">valuePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;-</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  let $xid := @xml:id</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  return if (@lemma) then @lemma </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  else if ($xid) then</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    following-sibling::tei:join[@lemma][matches(@target,&#39;#&#39;||$xid||&#39;( |$)&#39;)]/@lemma </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  else ()</span></span></code></pre></div><p>Note how we can easily split XPath expressions over multiple lines using <code>&gt;-</code> in YAML. (see <a href="https://yaml-multiline.info/" target="_blank" rel="noreferrer">YAML multiline strings</a>).</p> <h2 id="for-loops" tabindex="-1">For loops <a class="header-anchor" href="#for-loops" aria-label="Permalink to &quot;For loops&quot;">​</a></h2> <p>You can even use <code>for</code> loops if necessary, e.g.:</p> <div class="language-xquery vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xquery</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>for $w in //tei:w[@xml:id]</span></span>
<span class="line"><span>return let $xid := $w/@xml:id</span></span>
<span class="line"><span>    return </span></span>
<span class="line"><span>    if ($w/@lemma) then</span></span>
<span class="line"><span>        $w/@lemma else</span></span>
<span class="line"><span>            if ($xid) then</span></span>
<span class="line"><span>                let $join := $w/following-sibling::tei:join[@lemma][matches(@target,concat(&#39;#&#39;,$xid,&#39;( |$)&#39;))]</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>                $join/@lemma else</span></span>
<span class="line"><span>                ()</span></span></code></pre></div><p>Thanks to <a href="https://github.com/eduarddrenth" target="_blank" rel="noreferrer">@eduarddrenth</a> for the initial Saxon version and some of the examples.</p>`,41)]))}const m=e(n,[["render",l]]);export{u as __pageData,m as default};
