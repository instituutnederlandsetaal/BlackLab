import{_ as e,c as a,o as i,al as t}from"./chunks/framework.B3j7FRen.js";const k=JSON.parse('{"title":"Processing values","description":"","frontmatter":{},"headers":[],"relativePath":"guide/index-your-data/processing-values.md","filePath":"guide/030_index-your-data/050_processing-values.md","lastUpdated":1749639304000}'),n={name:"guide/index-your-data/processing-values.md"};function l(p,s,o,h,d,r){return i(),a("div",null,s[0]||(s[0]=[t(`<h1 id="processing-values" tabindex="-1">Processing values <a class="header-anchor" href="#processing-values" aria-label="Permalink to &quot;Processing values&quot;">â€‹</a></h1> <p>It is often useful to do some simple processing on a value just before it&#39;s added to the index. This could be a simple search and replace, or combining two fields into one for easier searching, etc. Or you might want to map a whole collection of values to different values. Both are possible.</p> <div class="tip custom-block"><p class="custom-block-title">Processing steps, or everything in XPath?</p> <p>When using <code>processor: saxon</code>, you can often achieve the same results using XPath expressions (<a href="./xpath-examples.html">examples</a>).</p> <p>Just use what works best in your case. Of course, when indexing a non-XML format such as CSV, processing steps are the
only option.</p></div> <p>To perform simple value mapping on a metadata field, use the <code>map</code> action in the <code>process</code> section:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  containerPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">metadata</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  fields</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">speciesGroup</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    valuePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">species</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Map (translate) values (key will be translated to corresponding value)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # In this example: translate species to the group they belong to</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">map</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mammals</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mammals</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        shark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">fish</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        herring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">fish</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # etc.</span></span></code></pre></div><p><code>process</code> can be used to perform simple string processing on (standoff) (sub)annotations and metadata values.</p> <p>For example, to process a metadata field value, simply add the <code>process</code> key with a list of actions to perform, like so:</p> <div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  containerPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">metadata</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  fields</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">author</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    valuePath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">author</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Do some processing on the contents of the author element before indexing</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    process</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # If empty, set a default value</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # (note that this could also be achieved using unknownCondition/unknownValue)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">default</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(unknown)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                          </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      # Normalize spaces</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">replace</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\\\</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">s+&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span></span></code></pre></div><p>These are all the available generic processing steps:</p> <table tabindex="0"><thead><tr><th>Processing Step</th> <th>Description</th></tr></thead> <tbody><tr><td><code>replace(find, replace)</code></td> <td>Do a regex search for <code>find</code> and replace each match with <code>replace</code>. Group references may be used. An optional parameter <code>keep</code> can be set to <code>both</code> to keep both the original strings and the results after applying the replace operation.</td></tr> <tr><td><code>ifempty(value)</code> or <code>ifempty(field)</code></td> <td>If the field is empty, set its value to either the specified value or the value of the specified field. If you refer to a field, make sure it is defined before this field (fields are processed in order). (NOTE: this processing step was previously called <code>default</code>)</td></tr> <tr><td><code>append(value)</code> or <code>append(field)</code></td> <td>Append the specified value or the value of the specified field, using a space as the separator character. You may also specify a different <code>separator</code> if you wish, including the empty string (<code>&quot;&quot;</code>).</td></tr> <tr><td><code>split(separator, keep)</code></td> <td>Split the field&#39;s value on the given separator and keep only the part indicated by <code>keep</code> (0-based). If <code>keep</code> is omitted, keep the first part. If <code>separator</code> is omitted, use <code>;</code>. The separator is a regex, and to split on special characters, those should be escaped by using a double backslash (<code>\\\\</code>). <code>keep</code> also allows two special values: <code>all</code> to keep all splits (instead of only the one at an index), and <code>both</code> to keep both the unsplit value as well as all the split parts.</td></tr> <tr><td><code>strip(chars)</code></td> <td>Strip specified chars from beginning and end. If <code>chars</code> is omitted, use space.</td></tr> <tr><td><code>map(table)</code></td> <td>Map values to other values. The table is a map from input to output values. If the input value is not in the table, it is left unchanged.</td></tr> <tr><td><code>sort</code></td> <td>Sort values using the default collator. This may help to ensure that the first term (which is the one used for sorting and grouping) is more predictable.</td></tr> <tr><td><code>unique</code></td> <td>Remove duplicate values from the field. You normally never need to do this as it is done automatically just before actually indexing the final terms.</td></tr></tbody></table> <p>These processing steps are more specific to certain data formats:</p> <table tabindex="0"><thead><tr><th>Processing Step</th> <th>Description</th></tr></thead> <tbody><tr><td><code>parsePos(posExpr, fieldName)</code></td> <td>Parse common part of speech expressions of the form <code>A(b=c,d=e)</code> where A is the main part of speech (e.g. <code>N</code> for noun), and b=c is a part of speech feature such as number=plural, etc. If you don&#39;t specify field (or specify an underscore <code>_</code> for field), the main part of speech is extracted. If you specify a feature name (e.g. <code>number</code>), that feature is extracted.</td></tr> <tr><td><code>chatFormatAgeToMonths(chatFormatAge)</code></td> <td>Convert age as reported in CHAT format to number of months.</td></tr> <tr><td><code>concatDate</code></td> <td>Concatenate 3 separate date fields into one, substituting unknown months and days with the first or last possible value. The output format is YYYYMMDD. Numbers are padded with leading zeroes.<br><strong>Requires 4 arguments:</strong><br><code>yearField</code>: the metadata field containing the numeric year<br><code>monthField</code>: the metadata field containing the numeric month (so &quot;12&quot; instead of &quot;december&quot; or &quot;dec&quot;)<br><code>dayField</code>: the metadata field containing the numeric day<br><code>autofill</code>: <code>start</code> to autofill missing month and day to the first possible value (01), or <code>end</code> to autofill the last possible value (12 for months, last day of the month in that year for days - takes into account leap years).<br>This step requires that at least the year is known. If the year is not known, no output is generated.</td></tr> <tr><td>If you would like a new processing step to be added, please let us know.</td> <td></td></tr></tbody></table>`,21)]))}const u=e(n,[["render",l]]);export{k as __pageData,u as default};
