import{_ as a,c as t,o as s,al as o}from"./chunks/framework.B3j7FRen.js";const h=JSON.parse('{"title":"Token-based querying","description":"","frontmatter":{},"headers":[],"relativePath":"guide/query-language/token-based.md","filePath":"guide/040_query-language/010_token-based.md","lastUpdated":1752156126000}'),n={name:"guide/query-language/token-based.md"};function i(p,e,l,c,r,d){return s(),t("div",null,e[0]||(e[0]=[o(`<h1 id="token-based-querying" tabindex="-1">Token-based querying <a class="header-anchor" href="#token-based-querying" aria-label="Permalink to &quot;Token-based querying&quot;">​</a></h1> <p>BlackLab started out as purely a token-based corpus engine. This section shows BCQL&#39;s token-based features.</p> <h2 id="matching-a-token" tabindex="-1">Matching a token <a class="header-anchor" href="#matching-a-token" aria-label="Permalink to &quot;Matching a token&quot;">​</a></h2> <p>With BCQL you can specify a pattern of tokens (i.e. words) you&#39;re looking for.</p> <p>A simple such pattern is:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[word=&quot;man&quot;]</span></span></code></pre></div><p>This simply searches for all occurrences of the word <em>man</em>.</p> <p>Each corpus has a default annotation; usually <em>word</em>. Using this fact, this query can be written even simpler:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;man&quot;</span></span></code></pre></div><p>NOTE: In BlackLab&#39;s CQL dialect, double and single quotes are interchangeable, but this is not true for all corpus engines.
We will use the more standard double quotes in our examples.</p> <h3 id="multiple-annotations" tabindex="-1">Multiple annotations <a class="header-anchor" href="#multiple-annotations" aria-label="Permalink to &quot;Multiple annotations&quot;">​</a></h3> <p>If your corpus includes the per-word annotations <em>lemma</em> (i.e. headword) and <em>pos</em> (part-of-speech, i.e. noun, verb, etc.), you can query those as well.</p> <p>For example:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[lemma=&quot;search&quot; &amp; pos=&quot;noun&quot;]</span></span></code></pre></div><p>This query would match <em>search</em> and <em>searches</em> where used as a noun. (your data may use different part-of-speech tags, of course)</p> <h3 id="negation" tabindex="-1">Negation <a class="header-anchor" href="#negation" aria-label="Permalink to &quot;Negation&quot;">​</a></h3> <p>You can use the &quot;does not equal&quot; operator (!=) to search for all words except nouns:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[pos != &quot;noun&quot;]</span></span></code></pre></div><h3 id="regular-expressions" tabindex="-1">Regular expressions <a class="header-anchor" href="#regular-expressions" aria-label="Permalink to &quot;Regular expressions&quot;">​</a></h3> <p>The strings between quotes can also contain &quot;wildcards&quot;, of sorts. To be precise, they are <a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noreferrer">regular expressions</a>, which provide a flexible way of matching strings of text. For example, to find <em>man</em> or <em>woman</em> (in the default annotation <em>word</em>), use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;(wo)?man&quot;</span></span></code></pre></div><p>And to find lemmas starting with <em>under</em>, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[lemma=&quot;under.*&quot;]</span></span></code></pre></div><p>Explaining regular expression syntax is beyond the scope of this document, but for a complete overview, see <a href="http://www.regular-expressions.info/" target="_blank" rel="noreferrer">regular-expressions.info</a> for a general overview, or <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/regexp-syntax.html" target="_blank" rel="noreferrer">Lucene&#39;s regular expression syntax</a> specifically, which has a few quirks.</p> <details class="details custom-block"><summary>Escaping and literal strings</summary> <p>To find characters with special meaning in a regular expression, such as the period, you need to escape them with a backslash:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[lemma=&quot;etc\\.&quot;]</span></span></code></pre></div><p>Alternatively, you can use a &quot;literal string&quot; by prefixing the string with an <code>l</code>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[lemma=l&#39;etc.&#39;]</span></span></code></pre></div><p>Note that some unexpected characters may be considered special regex characters, such as <code>&lt;</code> and <code>&gt;</code>. See the above link to Lucene&#39;s regex documentation for more details.</p></details> <h3 id="matching-any-token" tabindex="-1">Matching any token <a class="header-anchor" href="#matching-any-token" aria-label="Permalink to &quot;Matching any token&quot;">​</a></h3> <p>Sometimes you want to match any token, regardless of its value.</p> <p>Of course, this is usually only useful in a larger query, as we will explore next. But we&#39;ll introduce the syntax here.</p> <p>To match any token, use the match-all pattern, which is just a pair of empty square brackets:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[]</span></span></code></pre></div><h3 id="case-and-diacritics-sensitivity" tabindex="-1">Case- and diacritics sensitivity <a class="header-anchor" href="#case-and-diacritics-sensitivity" aria-label="Permalink to &quot;Case- and diacritics sensitivity&quot;">​</a></h3> <p>BlackLab defaults to (case and diacritics) <em>insensitive</em> search. That is, it ignores differences in upper- and lowercase, as well as diacritical marks (accented characters). So searching for <code>&quot;panama&quot;</code> will also find <em>Panama</em>.</p> <p>To match a pattern sensitively, prefix it with <code>(?-i)</code>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;(?-i)Panama&quot;</span></span></code></pre></div><h2 id="sequences" tabindex="-1">Sequences <a class="header-anchor" href="#sequences" aria-label="Permalink to &quot;Sequences&quot;">​</a></h2> <h3 id="simple-sequences" tabindex="-1">Simple sequences <a class="header-anchor" href="#simple-sequences" aria-label="Permalink to &quot;Simple sequences&quot;">​</a></h3> <p>You can search for sequences of words as well (i.e. phrase searches, but with many more possibilities). To search for the phrase <em>the tall man</em>, use this query:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;the&quot; &quot;tall&quot; &quot;man&quot;</span></span></code></pre></div><p>It might seem a bit clunky to separately quote each word, but this allows us the flexibility to specify exactly what kinds of words we&#39;re looking for.</p> <p>For example, if you want to know all single adjectives used with man (not just <em>tall</em>), use this:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;an?|the&quot; [pos=&quot;ADJ&quot;] &quot;man&quot;</span></span></code></pre></div><p>This would also match <em>a wise man</em>, <em>an important man</em>, <em>the foolish man</em>, etc.</p> <p>If we don&#39;t care about the part of speech between the article and <em>man</em>, we can use the match-all pattern we showed before:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;an?|the&quot; [] &quot;man&quot;</span></span></code></pre></div><p>This way we might match something like <em>the cable man</em> as well as <em>a wise man</em>.</p> <h3 id="repetitions" tabindex="-1">Repetitions <a class="header-anchor" href="#repetitions" aria-label="Permalink to &quot;Repetitions&quot;">​</a></h3> <p>Really powerful token-based queries become possible when you use the regular expression operators on whole tokens as well. If we want to see not just single adjectives applied to <em>man</em>, but multiple as well:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[pos=&quot;ADJ&quot;]+ &quot;man&quot;</span></span></code></pre></div><p>This query matches <em>little green man</em>, for example. The plus sign after <code>[pos=&quot;ADJ&quot;]</code> says that the preceding part should occur one or more times (similarly, <code>*</code> means &quot;zero or more times&quot;, and <code>?</code> means &quot;zero or once&quot;).</p> <p>If you only want matches with exactly two or three adjectives, you can specify that too:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[pos=&quot;ADJ&quot;]{2,3} &quot;man&quot;</span></span></code></pre></div><p>Or, for two or more adjectives:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[pos=&quot;ADJ&quot;]{2,} &quot;man&quot;</span></span></code></pre></div><p>You can group sequences of tokens with parentheses and apply operators to the whole group as well. To search for a sequence of nouns, each optionally preceded by an article:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(&quot;an?|the&quot;? [pos=&quot;NOU&quot;])+</span></span></code></pre></div><p>This would, for example, match the well-known palindrome <em>a man, a plan, a canal: Panama!</em> (provided the punctuation marks were not indexed as separate tokens)</p> <h3 id="lookahead-lookbehind" tabindex="-1">Lookahead/lookbehind <a class="header-anchor" href="#lookahead-lookbehind" aria-label="Permalink to &quot;Lookahead/lookbehind&quot;">​</a></h3> <div class="tip custom-block"><p class="custom-block-title">Supported from v4.0</p> <p>This feature is supported from BlackLab 4.0.</p></div> <p>Just like most regular expressions engines, BlackLab supports lookahead and lookbehind assertions. These match a position in the text but do not consume any tokens. They are useful for matching a token only if it is followed or preceded by other token(s).</p> <p>For example, to find the word <em>cat</em> only if it is followed by <em>in the hat</em>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;cat&quot; (?= &quot;in&quot; &quot;the&quot; &quot;hat&quot;)</span></span></code></pre></div><p>Similarly, to find the word <em>dog</em>, but only if it is preceded by <em>very good</em>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(?&lt;= &quot;very&quot; &quot;good&quot;) &quot;dog&quot;</span></span></code></pre></div><p>Negative lookahead is also supported. To only find <em>cat</em> if it is not followed by <em>call</em>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;cat&quot; (?! &quot;call&quot;)</span></span></code></pre></div><p>And negative lookbehind:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(?&lt;! &quot;bad&quot;) &quot;dog&quot;</span></span></code></pre></div><h3 id="finding-punctuation" tabindex="-1">Finding punctuation <a class="header-anchor" href="#finding-punctuation" aria-label="Permalink to &quot;Finding punctuation&quot;">​</a></h3> <p>(The following applies to corpora that index punctuation as the <code>punct</code> property of the next word, not to corpora that index punctuation as a separate token)</p> <p>Often in BlackLab, the punctuation and spaces between words will be indexed as a property named <code>punct</code>. This property always contains the spaces and interpunction that occurs before the word where it is indexed.</p> <p>Because of where it is indexed, it can be tricky to find specific punctuation <em>after</em> a certain word. To find the word <code>dog</code> followed by a comma, you&#39;d need to do something like this:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;dog&quot; [punct=&quot;, *&quot;]</span></span></code></pre></div><p>Because spaces are also indexed with the <code>punct</code> annotation, you need to include them in the regex as well.</p> <p>Starting with BlackLab 4.0.0, there are <em>pseudo-annotations</em> that can help with this. You can pretend that
every corpus has a <code>punctBefore</code> and <code>punctAfter</code> annotation. So you can write the above query as:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[word=&quot;dog&quot; &amp; punctAfter=&quot;,&quot;]</span></span></code></pre></div><p>Note that in special cases where more than one punctuation mark is indexed with a word, you may still need to tweak your regular expression. For example, if your input data contained the fragment &quot;(white) dog, (black) cat&quot;, the above query would not work because the <code>punct</code> annotation for the word after <code>dog</code> would have the value <code>, (</code>. You&#39;d have to use a more general regular expression:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[word=&quot;dog&quot; &amp; punctAfter=&quot;,.*&quot;]</span></span></code></pre></div><p>Note that <code>punctBefore</code> and <code>punctAfter</code> look like annotations when used in the query, but are not; they will not be in the results and you cannot group on them. You can group on the <code>punct</code> annotation they are based on, because that is actually a part of the index.</p> <h2 id="spans" tabindex="-1">Spans <a class="header-anchor" href="#spans" aria-label="Permalink to &quot;Spans&quot;">​</a></h2> <p>Your input data may contains &quot;spans&quot;: marked regions of text, such as paragraphs, sentences, named entities, etc. If your input data is XML these may be XML elements, but they may also be marked in other ways. Non-XML formats may also define spans.</p> <p>Finding text in relation to these spans is done using an XML-like syntax, regardless of the exact input data format.</p> <h3 id="finding-spans" tabindex="-1">Finding spans <a class="header-anchor" href="#finding-spans" aria-label="Permalink to &quot;Finding spans&quot;">​</a></h3> <p>If you want to find all the sentence spans in your data:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;s/&gt;</span></span></code></pre></div><p>Note that forward slash before the closing bracket. This way of referring to the span means &quot;the whole span&quot;. Compare this to <code>&lt;s&gt;</code>, which means &quot;the start of the span&quot;, and <code>&lt;/s&gt;</code>, which means &quot;the end of the span&quot;.</p> <p>So to find only the starts of sentences, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;s&gt;</span></span></code></pre></div><p>This would find zero-length hits at the position before the first word. Similarly, <code>&lt;/s&gt;</code> finds the ends of sentences. Not very useful, but we can combine these with other queries.</p> <h3 id="words-at-the-start-or-end-of-a-span" tabindex="-1">Words at the start or end of a span <a class="header-anchor" href="#words-at-the-start-or-end-of-a-span" aria-label="Permalink to &quot;Words at the start or end of a span&quot;">​</a></h3> <p>More useful might be to find the first word of each sentence:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;s&gt; []</span></span></code></pre></div><p>or sentences ending in <em>that</em>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;that&quot; &lt;/s&gt;</span></span></code></pre></div><p>(Note that this assumes the period at the end of the sentence is not indexed as a separate token - if it is, you would use <code>&quot;that&quot; &#39;.&#39; &lt;/s&gt;</code> instead)</p> <h3 id="words-inside-a-span" tabindex="-1">Words inside a span <a class="header-anchor" href="#words-inside-a-span" aria-label="Permalink to &quot;Words inside a span&quot;">​</a></h3> <p>You can also search for words occurring inside a specific span. Say you&#39;ve run named entity recognition on your data, so all names of people are tagged with the <code>person</code> span. To find the word <em>baker</em> as part of a person&#39;s name, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;baker&quot; within &lt;person/&gt;</span></span></code></pre></div><p>The above query will just match the word <em>baker</em> as part of a person&#39;s name. But you&#39;re likely more interested in the entire name that contains the word <em>baker</em>. So, to find those full names, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;person/&gt; containing &#39;baker&#39;</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Using a regular expression for the span name</p> <p>You can match multiple span types (e.g. both <code>&lt;person/&gt;</code> and <code>&lt;location/&gt;</code>) using a regular expression:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;baker&quot; within &lt;&quot;person|location&quot; /&gt;</span></span></code></pre></div><p>To match all spans in the corpus, use:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;&quot;.+&quot; /&gt;</span></span></code></pre></div></div> <div class="tip custom-block"><p class="custom-block-title">Capturing all overlapping spans</p> <p>If you want to know all spans that overlap each of your hits (for example, the sentence, paragraph and chapter it occurs
in, if you&#39;ve indexed those as spans), pass <code>withspans=true</code> as a parameter.</p> <p>Alternatively, you can adjust your query directly:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>with-spans(&quot;baker&quot;)</span></span></code></pre></div><p>or</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>with-spans(&quot;baker&quot;, &lt;&quot;person|location&quot; /&gt;, &quot;props&quot;)</span></span></code></pre></div><p>The second example will capture a list of matching spans in the match info named <code>props</code>.</p> <p>Only the first parameter for <code>with-spans</code> is required. The second parameter defaults to <code>&lt;&quot;.+&quot;/&gt;</code> (all tags); the third defaults to <code>&quot;with-spans&quot;</code>.</p></div> <h3 id="universal-operators" tabindex="-1">Universal operators <a class="header-anchor" href="#universal-operators" aria-label="Permalink to &quot;Universal operators&quot;">​</a></h3> <p>As you might have guessed, you can use <code>within</code> and <code>containing</code> with any other query as well. For example:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>([pos=&quot;ADJ&quot;]+ containing &quot;tall&quot;) &quot;man&quot;</span></span></code></pre></div><p>will find adjectives applied to man, where one of those adjectives is <em>tall</em>.</p> <h2 id="captures" tabindex="-1">Captures <a class="header-anchor" href="#captures" aria-label="Permalink to &quot;Captures&quot;">​</a></h2> <h3 id="part-of-the-match" tabindex="-1">Part of the match <a class="header-anchor" href="#part-of-the-match" aria-label="Permalink to &quot;Part of the match&quot;">​</a></h3> <p>Just like in regular expressions, it is possible to &quot;capture&quot; part of the match for your query as a named group. Everything you capture is returned with the hit in a response section called <em>match info</em>. You label each capture with a name.</p> <p>Example:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;an?|the&quot; A:[pos=&quot;ADJ&quot;] &quot;man&quot;</span></span></code></pre></div><p>The adjective part of the match will be captured in a group named <em>A</em>.</p> <p>You can capture multiple words as well:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;an?|the&quot; adjectives:[pos=&quot;ADJ&quot;]+ &quot;man&quot;</span></span></code></pre></div><p>This will capture the adjectives found for each match in a captured group named <em>adjectives</em>.</p> <p>The capture name can also just be a number:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;an?|the&quot; 1:[pos=&quot;ADJ&quot;]+ &quot;man&quot;</span></span></code></pre></div> <div class="tip custom-block"><p class="custom-block-title">Spans are captured automatically</p> <p>If your query involves spans like <code>&lt;s/&gt;</code>, it will automatically be captured under the span name (<code>s</code> in this case). You can override the capture name by specifying it in the query, e.g. <code>A:&lt;s/&gt;</code>.</p></div> <h3 id="constraints" tabindex="-1">Constraints <a class="header-anchor" href="#constraints" aria-label="Permalink to &quot;Constraints&quot;">​</a></h3> <p>If you tag certain tokens with labels, you can also apply &quot;capture constraints&quot; (also known as &quot;global constraints&quot;)
on these tokens. This is a way of relating different tokens to one another, for example requiring that they correspond
to the same word:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A:[] &quot;by&quot; B:[] :: A.word = B.word</span></span></code></pre></div><p>This would match <em>day by day</em>, <em>step by step</em>, etc.</p> <details class="details custom-block"><summary>Multiple-value annotations and constraints</summary> <p>Unfortunately, capture constraints can only access the first value indexed for an annotation. If you need this kind of
functionality in combination with multi-values constraints, you&#39;ll have to find a way around this limitation.</p> <p>Some queries can be rewritten so they don&#39;t need a capture constraint. For example,
<code>A:[word=&quot;some&quot;] B:[word=&quot;queries&quot;] :: A.lemma=&quot;some&quot; &amp; B.lemma=&quot;query&quot;</code> can also be written as
<code>A:[word=&quot;some&quot; &amp; lemma=&quot;some&quot;] B:[word=&quot;queries&quot; &amp; lemma=&quot;query&quot;]</code>, which does work with multiple annotation values.
But this is rare.</p> <p>In other cases, you might be able to add extra annotations or use spans (&quot;inline tags&quot;) to get around this limitation.</p></details> <h3 id="constraint-functions" tabindex="-1">Constraint functions <a class="header-anchor" href="#constraint-functions" aria-label="Permalink to &quot;Constraint functions&quot;">​</a></h3> <p>You can also use a few special functions in capture constraints. For example, ensure that words occur in the right order:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(&lt;s&gt; containing A:&quot;cat&quot;) containing B:&quot;fluffy&quot; :: start(B) &lt; start(A)</span></span></code></pre></div><p>Here we find sentences containing both <em>cat</em> and <em>fluffy</em> (in some order), but then require that <em>fluffy</em> occurs before <em>cat</em>.</p> <p>Of course this particular query would be better expressed as <code>&lt;s/&gt; containing &quot;fluffy&quot; []* &quot;cat&quot;</code>. As a general rule,
capture constraints can be a bit slower, so only use them when you need to.</p> <h3 id="local-capture-constraints" tabindex="-1">Local capture constraints <a class="header-anchor" href="#local-capture-constraints" aria-label="Permalink to &quot;Local capture constraints&quot;">​</a></h3> <p>Unlike most other corpus engines, BlackLab allows you to place capture constraints inside a parenthesized expression.
Be careful that the constraint only refers to labels that are captured inside the parentheses, though!</p> <p>This is valid and would match <em>over and over again</em>:</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(A:[] &quot;and&quot; B:[] :: A.word = B.word) &quot;again&quot;</span></span></code></pre></div><p>This is NOT valid (may not produce an error, but the results are undefined):</p> <div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A:[] (&quot;and&quot; B:[] :: A.word = B.word) &quot;again&quot;   # BAD</span></span></code></pre></div>`,231)]))}const m=a(n,[["render",i]]);export{h as __pageData,m as default};
